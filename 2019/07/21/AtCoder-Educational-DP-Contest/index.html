<!DOCTYPE html>
<html lang=zh>
<head><meta name="generator" content="Hexo 3.8.0">
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="description" content="AtCoder - Educational DPD - 01背包空间复杂度优化一开始我们可以得到方程:  dp[i][v] = \mathrm{max}(dp[i - 1][v], dp[i - 1][v - \mathrm{volumn}[i]] + \mathrm{value}[i])$\mathrm{max}$中的两项分别代表了不取当前物品，和取当前物品。 跟其他背包入门不一样，我采用的不是">
<meta name="keywords" content="ACM,dp">
<meta property="og:type" content="article">
<meta property="og:title" content="AtCoder Educational DP Contest">
<meta property="og:url" content="https://medioqrity.github.io/2019/07/21/AtCoder-Educational-DP-Contest/index.html">
<meta property="og:site_name" content="Medioqrity&#39;s Blog">
<meta property="og:description" content="AtCoder - Educational DPD - 01背包空间复杂度优化一开始我们可以得到方程:  dp[i][v] = \mathrm{max}(dp[i - 1][v], dp[i - 1][v - \mathrm{volumn}[i]] + \mathrm{value}[i])$\mathrm{max}$中的两项分别代表了不取当前物品，和取当前物品。 跟其他背包入门不一样，我采用的不是">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://medioqrity.github.io/2019/07/21/AtCoder-Educational-DP-Contest/1547687969962.png">
<meta property="og:updated_time" content="2019-07-23T16:03:17.118Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="AtCoder Educational DP Contest">
<meta name="twitter:description" content="AtCoder - Educational DPD - 01背包空间复杂度优化一开始我们可以得到方程:  dp[i][v] = \mathrm{max}(dp[i - 1][v], dp[i - 1][v - \mathrm{volumn}[i]] + \mathrm{value}[i])$\mathrm{max}$中的两项分别代表了不取当前物品，和取当前物品。 跟其他背包入门不一样，我采用的不是">
<meta name="twitter:image" content="https://medioqrity.github.io/2019/07/21/AtCoder-Educational-DP-Contest/1547687969962.png">
    
    
        
          
              <link rel="shortcut icon" href="/images/favicon.ico">
          
        
        
          
            <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
          
        
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
          
        
    
    <!-- title -->
    <title>AtCoder Educational DP Contest</title>
    <!-- styles -->
    <link rel="stylesheet" href="/css/style.css">
    <!-- persian styles -->
    
      <link rel="stylesheet" href="/css/rtl.css">
    
    <!-- rss -->
    
    
    <link href="https://cdn.bootcss.com/KaTeX/0.7.1/katex.min.css" rel="stylesheet"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>
<body class="max-width mx-auto px3 ltr">    
      <!-- hexo-inject:begin --><!-- hexo-inject:end --><div id="header-post">
  <a id="menu-icon" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">首页</a></li>
         
          <li><a href="/archives/">文章</a></li>
         
          <li><a href="/about/">关于</a></li>
        
      </ul>
    </span>
    <br>
    <span id="actions">
      <ul>
        
        
        <li><a class="icon" href="/2019/07/15/小学期开发记录-第四周/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">上一篇</span>
      <span id="i-next" class="info" style="display:none;">下一篇</span>
      <span id="i-top" class="info" style="display:none;">返回顶部</span>
      <span id="i-share" class="info" style="display:none;">分享文章</span>
    </span>
    <br>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=https://medioqrity.github.io/2019/07/21/AtCoder-Educational-DP-Contest/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=https://medioqrity.github.io/2019/07/21/AtCoder-Educational-DP-Contest/&text=AtCoder Educational DP Contest"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https://medioqrity.github.io/2019/07/21/AtCoder-Educational-DP-Contest/&title=AtCoder Educational DP Contest"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https://medioqrity.github.io/2019/07/21/AtCoder-Educational-DP-Contest/&is_video=false&description=AtCoder Educational DP Contest"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=AtCoder Educational DP Contest&body=Check out this article: https://medioqrity.github.io/2019/07/21/AtCoder-Educational-DP-Contest/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=https://medioqrity.github.io/2019/07/21/AtCoder-Educational-DP-Contest/&title=AtCoder Educational DP Contest"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=https://medioqrity.github.io/2019/07/21/AtCoder-Educational-DP-Contest/&title=AtCoder Educational DP Contest"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=https://medioqrity.github.io/2019/07/21/AtCoder-Educational-DP-Contest/&title=AtCoder Educational DP Contest"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=https://medioqrity.github.io/2019/07/21/AtCoder-Educational-DP-Contest/&title=AtCoder Educational DP Contest"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=https://medioqrity.github.io/2019/07/21/AtCoder-Educational-DP-Contest/&name=AtCoder Educational DP Contest&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#AtCoder-Educational-DP"><span class="toc-number">1.</span> <span class="toc-text">AtCoder - Educational DP</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#D-01背包"><span class="toc-number">1.1.</span> <span class="toc-text">D - 01背包</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#空间复杂度优化"><span class="toc-number">1.1.1.</span> <span class="toc-text">空间复杂度优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#另一个优化"><span class="toc-number">1.1.2.</span> <span class="toc-text">另一个优化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#E-01背包变体"><span class="toc-number">1.2.</span> <span class="toc-text">E - 01背包变体</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#优化空间复杂度"><span class="toc-number">1.2.1.</span> <span class="toc-text">优化空间复杂度</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#F-Longest-Common-Substring"><span class="toc-number">1.3.</span> <span class="toc-text">F - Longest Common Substring</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#输出最长公共子序列"><span class="toc-number">1.3.1.</span> <span class="toc-text">输出最长公共子序列</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#G-Longest-Path"><span class="toc-number">1.4.</span> <span class="toc-text">G - Longest Path</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#H-Grid-1"><span class="toc-number">1.5.</span> <span class="toc-text">H - Grid 1</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#I-Coins"><span class="toc-number">1.6.</span> <span class="toc-text">I - Coins</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#J-Sushi"><span class="toc-number">1.7.</span> <span class="toc-text">J - Sushi</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#思考过程"><span class="toc-number">1.7.1.</span> <span class="toc-text">思考过程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#M-Candies"><span class="toc-number">1.8.</span> <span class="toc-text">M - Candies</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#N-Slimes"><span class="toc-number">1.9.</span> <span class="toc-text">N - Slimes</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#O-Matching"><span class="toc-number">1.10.</span> <span class="toc-text">O - Matching</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#P-Independent-Set"><span class="toc-number">1.11.</span> <span class="toc-text">P - Independent Set</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Q-Flowers"><span class="toc-number">1.12.</span> <span class="toc-text">Q - Flowers</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#R-Walk"><span class="toc-number">1.13.</span> <span class="toc-text">R - Walk</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#S-Digit-Sum"><span class="toc-number">1.14.</span> <span class="toc-text">S - Digit Sum</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#T-Permutation"><span class="toc-number">1.15.</span> <span class="toc-text">T - Permutation</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#U-Grouping"><span class="toc-number">1.16.</span> <span class="toc-text">U - Grouping</span></a></li></ol></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        AtCoder Educational DP Contest
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">Medioqrity's Blog</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2019-07-21T06:19:02.000Z" itemprop="datePublished">2019-07-21</time>
        
      
    </div>


      

      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link" href="/tags/ACM/">ACM</a>, <a class="tag-link" href="/tags/dp/">dp</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <h1 id="AtCoder-Educational-DP"><a href="#AtCoder-Educational-DP" class="headerlink" title="AtCoder - Educational DP"></a>AtCoder - Educational DP</h1><h2 id="D-01背包"><a href="#D-01背包" class="headerlink" title="D - 01背包"></a>D - 01背包</h2><h3 id="空间复杂度优化"><a href="#空间复杂度优化" class="headerlink" title="空间复杂度优化"></a>空间复杂度优化</h3><p>一开始我们可以得到方程:</p>
<script type="math/tex; mode=display">
dp[i][v] = \mathrm{max}(dp[i - 1][v], dp[i - 1][v - \mathrm{volumn}[i]] + \mathrm{value}[i])</script><p>$\mathrm{max}$中的两项分别代表了<em>不取当前物品</em>，和<em>取当前物品</em>。</p>
<p>跟其他背包入门不一样，我采用的不是$\mathrm{weight}$而是$\mathrm{volumn}$。这是因为一个背包，它可以装入的东西的质量几乎是没有上限的。相反，更多的是受到体积的制约:</p>
<ul>
<li>你可以放小小一勺中子星进背包。质量大概是<strong>几千辆卡车</strong>。</li>
<li>你可以放满满当当一背包棉花糖。质量，大概是<strong>几千分之一辆卡车</strong>。</li>
<li>你在吃鸡时总是更倾向于捡起并使用三级包而不是二级包。</li>
</ul>
<p>所以我坚持使用$\mathrm{volumn}$，尽管这样就和价值value的首字母撞了。但我想在学习过程中没有必要太在意简写问题。</p>
<p>然后，观察方程，我们可以发现，每一次都是从$dp[i - 1]$得出$dp[i]$，而<strong>再也不会跟更久以前的状态发生关系</strong>。所以我们考虑删去第一项$i$。</p>
<p>考虑$dp[v]$，显然有:</p>
<script type="math/tex; mode=display">
dp[v] = \mathrm{max}(dp[v], dp[v - \mathrm{volumn}[i]] + \mathrm{value}[i])</script><p>注意到这里$v \le v$，同时$v - \mathrm{volumn}[i] \le v$。</p>
<p>也就是说我们<strong>要使用的状态的体积总是小于等于当前状态的体积</strong>。所以我们只要从体积大的地方开始更新就可以啦！</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= object_count; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> w = max_weight; ~w; --w) &#123;  <span class="comment">// &lt;-- here!!!</span></span><br><span class="line">        <span class="keyword">if</span> (w &gt;= weight[i]) &#123;</span><br><span class="line">            dp[w] = max(dp[w], dp[w - weight[i]] + value[i]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dp[w] = dp[w];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意第二行的<code>for (int w = max_weight; ~w; --w)</code>，这就是对$\mathrm{volumn}$进行逆序更新了。<em>（写代码的时候还是按照w来吧。跟value撞了也确实是没办法。</em></p>
<p>提交结果:</p>
<p><img src="//medioqrity.github.io/2019/07/21/AtCoder-Educational-DP-Contest/1547687969962.png" alt="1547687969962"></p>
<p>因为访存地址变得连续，外加cache的存在的缘故，cache命中率变高，需要访存的次数少了，程序运行速度也就快了，同时空间复杂度也降低了很多。</p>
<p><strong>可以说是一个非常实用的优化了。</strong></p>
<h3 id="另一个优化"><a href="#另一个优化" class="headerlink" title="另一个优化"></a>另一个优化</h3><p>当完成上一个优化之后，我们的代码变成了这样:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> w = max_weight; ~w; --w) &#123;  <span class="comment">// &lt;-- here!!!</span></span><br><span class="line">    <span class="keyword">if</span> (w &gt;= weight[i]) &#123;</span><br><span class="line">        dp[w] = max(dp[w], dp[w - weight[i]] + value[i]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dp[w] = dp[w];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有没有发现，当<code>w &lt; weight[i]</code>的时候，其实我们对<code>dp[w]</code>不会进行任何更改?</p>
<p>所以<code>w &lt; weight[i]</code>的部分<strong>我们根本不用处理</strong>！</p>
<p>于是，我们可以把循环的条件改成<code>w &gt;= weight[i]</code>，中间可以省去if和else:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> w = max_weight; w &gt;= weight[i]; --w) &#123;</span><br><span class="line">    dp[w] = max(dp[w], dp[w - weight[i]] + value[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就是为什么别人的代码总是看起来很难懂的样子: 为什么要倒着跑w? 为什么跑到weight[i]就结束了?</p>
<p>一步步推导过来，其实谁都能理解。</p>
<h2 id="E-01背包变体"><a href="#E-01背包变体" class="headerlink" title="E - 01背包变体"></a>E - 01背包变体</h2><p>以上的代码适用于$1 \le \mathrm{Volumn} \le 10^5, 1 \le v_i \le 10^9$的情况。</p>
<p>当$1 \le \mathrm{Volumn} \le 10^9, 1 \le v_i \le 10^3$时，应该怎么办呢?</p>
<p>显然已经不能再按照上面的方法解决了，因为光是一次<code>for</code>就需要一秒。</p>
<p>但是注意到$v_i$的范围不同了。所以显然这一次的dp方法会要求我们利用$v_i$。</p>
<p>尝试将$dp[i][volumn]$的第二项换成$\mathrm{value}$:</p>
<ul>
<li><p><strong>首先，明确$dp[i][v]$的含义。</strong></p>
<p>  不妨定义为此时需要的最少背包容量，也就是:</p>
<p>  同样可以简单地用”取或不取”来分别对应max函数中的项。</p>
<ul>
<li><p><strong>在前i个物品(包括第i个)中选取得到v的价值时，所需要使用的<em>最少</em>的背包容量。</strong></p>
<p>根据这个定义，我们不难写出递推式:</p>
<script type="math/tex; mode=display">
dp[i][v] = \mathrm{min}(dp[i - 1][v], dp[i - 1][v - \mathrm{value}[i]] + \mathrm{volumn}[i])</script><p>同样可以简单地用”取或不取”来分别对应max函数中的项。</p>
</li>
</ul>
</li>
</ul>
<p><strong>这里有个小陷阱: </strong>题目里告诉你$1 \le v_i \le 10^3$，实际上你的value最大可能到$10^3 \times 100 = 10^5$。</p>
<p>所以还是要预留$10^5$的空间。 </p>
<p>然后老样子，先不考虑空间复杂度的优化，试试看这个代码跑得怎样。</p>
<p>跑出来答案总是0。</p>
<p>这是显然的，如果一开始dp整个数组全是0，那么:</p>
<p>$dp[i][v] = \mathrm{min}(0, 0 + \mathrm{volumn}[i]) = 0$</p>
<p><strong>显然，是因为没有初始化的错误。</strong></p>
<p>如果我们让所有<code>v == 0</code>时的情况都定义为0，其他情况都定义为<code>inf</code>，那么就可以得到正确答案:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">1</span>; v &lt; MAXV; ++v) dp[<span class="number">0</span>][v] = inf;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= object_count; ++i) &#123;</span><br><span class="line">    dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">1</span>; v &lt; MAXV; ++v) dp[i][v] = inf;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">1</span>; v &lt; MAXV; ++v) &#123;</span><br><span class="line">        <span class="keyword">if</span> (v &gt;= value[i]) &#123;</span><br><span class="line">            dp[i][v] = min(dp[i - <span class="number">1</span>][v], dp[i - <span class="number">1</span>][v - value[i]] + weight[i]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dp[i][v] = dp[i - <span class="number">1</span>][v];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="优化空间复杂度"><a href="#优化空间复杂度" class="headerlink" title="优化空间复杂度"></a>优化空间复杂度</h3><p>同样地，我们又一次发现，其实$dp[i]$还是只跟$dp[i - 1]$的状态有关系。</p>
<p>所以我们可以简化成这样的式子:</p>
<script type="math/tex; mode=display">
d[v] = \mathrm{min}(dp[v], dp[v - \mathrm{value}[i]] + \mathrm{volumn}[i])</script><p>注意到$v - \mathrm{value}[i] \le v$，所以我们还是要从大的v向小的v进行迭代。</p>
<p>加上<code>v &gt;= value[i]</code>的条件，我们可以化简成:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">1</span>; v &lt; MAXV; ++v) dp[v] = inf;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= object_count; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v = MAXV - <span class="number">1</span>; v &gt;= value[i]; --v) &#123;</span><br><span class="line">        dp[v] = min(dp[v], dp[v - value[i]] + weight[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="F-Longest-Common-Substring"><a href="#F-Longest-Common-Substring" class="headerlink" title="F - Longest Common Substring"></a>F - Longest Common Substring</h2><p>虽然以前做过这道题，但是毕竟是看完别人的题解就立刻跟着敲，实际上没学到什么。</p>
<p>借着这次机会好好重新想想这个应该怎么写吧。</p>
<p>定义$dp[i][j]$表示字符串$s, t$的切片$s[:i + 1], t[:j + 1]$的最长公共子序列。</p>
<p>那么我们很容易就能够得到状态转移表达式:</p>
<p>$dp[i][j] = dp[i - 1][j - 1] + 1$，当$s[i] == t[j]$。</p>
<p>关于为什么只能从$i - 1$和$j - 1$转换过来，其实非常好理解，因为当$i - 1$和$j - 1$这两个位置都被选中之后，就不能再被使用了。</p>
<p>但是关键问题就在于，$dp[i][j]$和$dp[i - 1][j]$之间的关系还要再考虑一下。</p>
<p>有没有$dp[i][j] = dp[i - 1][j] + 1$的情况呢? 不妨试着构造一下。</p>
<p>$s = \text{‘aasdf’}, t = \text{‘asdf’}$</p>
<p>$\mathrm{LCS}(\text{‘aasdf’}, \text{‘asdf’}) = \mathrm{LCS}(\text{‘aasd’}, \text{‘asdf’}) + 1$</p>
<p>如果考虑$dp[i][j - 1]$，有</p>
<p>$\mathrm{LCS}(\text{‘aasdf’}, \text{‘asdf’}) = \mathrm{LCS}(\text{‘aasdf’}, \text{‘asd’}) + 1$</p>
<p>仔细一看，因为最后一位都是<code>&#39;f&#39;</code>，所以说都增加1是理所应当的。那么显然，这种情况就无需考虑了。</p>
<p>那有没有$dp[i][j] = dp[i - 1][j]$的情况呢? 我想那是必须的，能够造出来吧。</p>
<p>但是其实，此时，$dp[i][j] = dp[i - 1][j - 1] + 1$。所以最后不论如何都会+1，无需考虑。</p>
<p>再考虑一下$s[i] \ne t[j]$的情况，此时有没有可能导致$dp[i][j] = dp[i - 1][j] + 1$呢?</p>
<p>应该是可以的，比方说</p>
<p>$s = \text{‘abcd’}, t = \text{‘aabc’}$.</p>
<p>$LCS(\text{‘abcd’}, \text{‘aabc’}) = LCS(\text{‘abcd’}, \text{‘aab’}) + 1$</p>
<p>但是，$LCS(\text{‘abc’}, \text{‘aabc’}) = 3$.</p>
<p>也就是说，新的LCS在$s[i] \ne t[j]$时，总是尽可能的取$dp[i - 1][j]$和$dp[i][j - 1]$的最大值。</p>
<script type="math/tex; mode=display">
dp[i][j] = dp[i - 1][j - 1] + 1</script><p>如果$s[i] = t[j]$。</p>
<script type="math/tex; mode=display">
dp[i][j] = \mathrm{max}(dp[i - 1][j], dp[i][j - 1])</script><p>如果$s[i]\ne t[j]$。</p>
<h3 id="输出最长公共子序列"><a href="#输出最长公共子序列" class="headerlink" title="输出最长公共子序列"></a>输出最长公共子序列</h3><p>找出状态转移公式并求出解来并不麻烦，但是要找出这个解究竟是什么样的就不是那么好办了。</p>
<p>因为dp数组本身只是记录了最长公共子序列的长度，并没有记录最关键的信息: 字符串。</p>
<p>好在有一个非常通用的技巧: 在每个状态的地方记录一下<strong>当前状态是从哪个状态转移来的</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (s[i] == t[j]) &#123;</span><br><span class="line">    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">    from[i][j][<span class="number">0</span>] = i - <span class="number">1</span>, from[i][j][<span class="number">1</span>] = j - <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (dp[i][j - <span class="number">1</span>] &gt; dp[i - <span class="number">1</span>][j]) &#123;</span><br><span class="line">        dp[i][j] = dp[i][j - <span class="number">1</span>];</span><br><span class="line">        from[i][j][<span class="number">0</span>] = i, from[i][j][<span class="number">1</span>] = j - <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">        from[i][j][<span class="number">0</span>] = i - <span class="number">1</span>, from[i][j][<span class="number">1</span>] = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，from数组就是记录第(i, j)状态是从哪个状态转移来的。</p>
<p>输出时，只要<strong>递归地逆流而上</strong>就可以了:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((!x) || (!y)) <span class="keyword">return</span>;</span><br><span class="line">    print(from[x][y][<span class="number">0</span>], from[x][y][<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span> (s[x] == t[y]) <span class="built_in">putchar</span>(s[x]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后就可以喜提AC啦！</p>
<h2 id="G-Longest-Path"><a href="#G-Longest-Path" class="headerlink" title="G - Longest Path"></a>G - Longest Path</h2><p>给你一个无权值的DAG，问你最长路的长度。</p>
<p>这题我一时半会没想好dp的解法，就拿拓扑排序乱搞过了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 100005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[MAXN];</span><br><span class="line"><span class="keyword">int</span> in_deg[MAXN];</span><br><span class="line"><span class="keyword">int</span> order[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    G[u].push_back(v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, u, v;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line">        add_edge(u, v);</span><br><span class="line">        ++in_deg[v];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; p;</span><br><span class="line">    <span class="built_in">queue</span>&lt;p&gt; que;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!in_deg[i]) &#123;</span><br><span class="line">            que.push(make_pair(<span class="number">0</span>, i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line">        p cur = que.front();</span><br><span class="line">        order[cur.second] = cur.first;</span><br><span class="line">        que.pop();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it : G[cur.second]) &#123;</span><br><span class="line">            --in_deg[it];</span><br><span class="line">            <span class="keyword">if</span> (!in_deg[it]) que.push(make_pair(cur.first + <span class="number">1</span>, it));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) ans = max(ans, order[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要是用dp做的话，要怎么定义状态呢?</p>
<p>dp[i]表示从i出发能够走的最远的距离?</p>
<p>dp[i]表示到i的路径的最远的距离?</p>
<p>诶，感觉下面这个好像可以有，从入度为0的地方开始bfs?</p>
<p>毕竟可以这样:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it : G[cur]) &#123;</span><br><span class="line">    <span class="keyword">if</span> (dp[cur] + <span class="number">1</span> &gt; dp[it]) &#123;</span><br><span class="line">        que.push(it);</span><br><span class="line">        dp[it] = dp[cur] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后扫一遍dp数组就可以了?的样子。</p>
<p>回头再试试看吧。</p>
<h2 id="H-Grid-1"><a href="#H-Grid-1" class="headerlink" title="H - Grid 1"></a>H - Grid 1</h2><p>水题，注意细节。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 1005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> h, w;</span><br><span class="line">ll dp[MAXN][MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;h, &amp;w);</span><br><span class="line">    <span class="keyword">char</span> temp;</span><br><span class="line">    getchar();</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= h; ++i, getchar()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= w; ++j) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%c"</span>, &amp;temp);</span><br><span class="line">            <span class="keyword">if</span> (temp == <span class="string">'.'</span>) &#123;</span><br><span class="line">                dp[i][j] = (dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>]) % MOD;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, dp[h][w]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="I-Coins"><a href="#I-Coins" class="headerlink" title="I - Coins"></a>I - Coins</h2><p>给你很多个(&lt;=2999个)硬币。告诉你每个硬币朝上的概率，问你硬币朝上个数大于硬币朝下个数的概率是多少?</p>
<p>这就是传说中的概率dp吗…（惊叹</p>
<p>感觉呢很容易就能想到定义$dp[i]$指到第i个硬币，硬币朝上个数大于硬币朝下个数的概率。</p>
<p>可是我要怎么确保硬币朝上的个数总是大于硬币朝下的个数呢???</p>
<p>我又不可能在dp[i]里面把所有情况的概率都分别记录一下啊??</p>
<p>诶，突然灵机一动！！</p>
<p>显然那些概率还是得记录一下的！！而且有办法记录！</p>
<p>$dp[i][j]$表示到第i个硬币，取了j个向上的概率。</p>
<p>于是</p>
<script type="math/tex; mode=display">
\begin{align*}
dp[i][j] =& dp[i - 2][j - 2] \cdot p[i - 1] \cdot p[i] + \\
&dp[i - 2][j - 1] \cdot ((p[i - 1] \cdot (1 - p[i])) + ((1 - p[i - 1]) \cdot p[i])) + \\
&dp[i - 2][j] \cdot ((1 - p[i - 1]) \cdot (1 - p[i]))
\end{align*}</script><p>接近$O(n^2)$的复杂度的样子。</p>
<p>先去写写看。 </p>
<hr>
<p>然后就AC了。</p>
<p>一开始把dp[i - 2][j - 1]的递推式写错了（滥用容斥），害得调试了半天。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 3000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> dp[MAXN][MAXN];</span><br><span class="line"><span class="keyword">double</span> p[MAXN];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1.</span> - p[<span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">1</span>] = p[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i += <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &gt;= <span class="number">2</span>)</span><br><span class="line">                dp[i][j] += dp[i - <span class="number">2</span>][j - <span class="number">2</span>] * p[i - <span class="number">1</span>] * p[i];</span><br><span class="line">            <span class="keyword">if</span> (j &gt;= <span class="number">1</span>)</span><br><span class="line">                dp[i][j] += dp[i - <span class="number">2</span>][j - <span class="number">1</span>] * ((p[i - <span class="number">1</span>] * (<span class="number">1</span> - p[i])) + ((<span class="number">1</span> - p[i - <span class="number">1</span>]) * p[i]));</span><br><span class="line">            dp[i][j] += dp[i - <span class="number">2</span>][j] * ((<span class="number">1</span> - p[i - <span class="number">1</span>]) * (<span class="number">1</span> - p[i]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lf"</span>, p + i);</span><br><span class="line">    &#125;</span><br><span class="line">    solve();</span><br><span class="line">    <span class="keyword">double</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = (n &gt;&gt; <span class="number">1</span>) + <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">        ans += dp[n][j];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.10lf\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="J-Sushi"><a href="#J-Sushi" class="headerlink" title="J - Sushi"></a>J - Sushi</h2><p>一共有n个碟子，每次等概率选中一个。</p>
<p>每个碟子上有a[i]，0 &lt;= a[i] &lt;= 3个寿司。</p>
<p>如果选中了有寿司的碟子就吃掉那其中的1个寿司。</p>
<p>问你全部吃完时，选择盘子次数的期望值是多少?</p>
<h3 id="思考过程"><a href="#思考过程" class="headerlink" title="思考过程"></a>思考过程</h3><p>可以这样考虑:</p>
<p>当目前有m个盘子有寿司时，吃掉一个寿司的概率为$\dfrac mn$，想要吃掉一个寿司，期望的选择次数为$\dfrac nm$。</p>
<p>然后吃掉一个寿司后有一定概率就变成k-1个盘子有寿司了，这得看你吃的是哪个。</p>
<p>诶，好像看到了希望！</p>
<p>也就是说，吃掉一个寿司后，剩余k-1个盘子的概率是a[i] == 1的盘子的个数，除以k。</p>
<p>剩余k个盘子的概率是a[i] &gt; 1的盘子的个数，除以k。</p>
<p>然后就是继续吃寿司。。继续吃寿司。。。。。</p>
<p>那么看起来有一个寿司的盘子的个数，和有两个寿司的盘子的个数，和有三个寿司的盘子的个数，都应该是是dp的参数。</p>
<p>那么设定dp[i][j][k]为有i个有一个寿司的盘子，有j个有两个寿司的盘子，有k个有3个寿司的盘子。</p>
<script type="math/tex; mode=display">
\begin{align*}
dp[i][j][k] =& 
dp[i + 1][j][k] \times \frac{i + 1}{n}+ \\ 
& dp[i - 1][j + 1][k] \times \frac{2j + 2}{n} + \\ 
& dp[i][j - 1][k + 1] \times \frac{3k + 3}{n} + \\
& dp[i][j][k] \times \frac{i + 2j + 3k}{n}?
\end{align*}</script><p>几乎是正确的。但是因为对概率还是了解的不够深刻，所以吃了亏。</p>
<p>首先，一些小错误。从碟子里面选出项数为3的并不用乘3倍。k+1就可以了。</p>
<p>然后，<del>并不是从自己转移到自己</del> 其实是。而是在从子状态转移过来之前，需要有好多次多余的，也就是跑到空盘子上的次数。</p>
<p>于是应该修正为这样:</p>
<script type="math/tex; mode=display">
\begin{align*}
dp[i][j][k] =& 
dp[i + 1][j][k] \times \frac{i + 1}{n}+ \\ 
& dp[i - 1][j + 1][k] \times \frac{j + 1}{n} + \\ 
& dp[i][j - 1][k + 1] \times \frac{k + 1}{n} + \\
& \frac{n}{i + j + k}
\end{align*}</script><p>其中，$\dfrac{n}{i + j + k}$代表的是为了到达选中1个或两个或三个碟子的情况所需要的期望次数。</p>
<p>但是这点还没理解为什么。等理解了再回来继续写。</p>
<p>还有一些别的疑问。类似于:</p>
<p>CF的讨论区里，红名大佬给出了以下递推式:</p>
<script type="math/tex; mode=display">
\begin{align*}
dp[cnt_1][cnt_2][cnt_3] =
& \frac{n - (cnt_1 + cnt_2 + cnt_3)}{n}dp[cnt_1][cnt_2][cnt_3] + \\
& \frac{cnt_1}{n}dp[cnt_1-1][cnt_2][cnt_3] + \\
& \frac{cnt_2}{n}dp[cnt_1+1][cnt_2-1][cnt_3] + \\
& \frac{cnt_3}{n}dp[cnt_1][cnt_2+1][cnt_3-1] + \\
& 1
\end{align*}</script><p>不妨想一想每一项的意思都是什么。</p>
<p>最神奇的事情就是，在不知道$dp[cnt_1][cnt_2][cnt_3]$的初值时，就开始进行更新。</p>
<p>然后，最不能够理解的就是，为什么吃掉一个只有一个sushi的盘子，竟然是$cnt_1 - 1$?</p>
<p>难道不是之前有$cnt_1 + 1$个盘子，吃掉这个盘子之后就减去1，变成了$cnt_1$了吗?</p>
<p>背包问题里，$dp[i][v]$是从$dp[i - 1][v], dp[i - 1][v - Volumn[i]] + value[i]$这样子搞出来的。</p>
<p>也就是从背包容量上限比较小的地方搞上来的。</p>
<p>然后这里我们是从寿司个数更多的地方搞下来的，所以怎么想都应该是用+才对呀。</p>
<hr>
<p>时隔几个月，在取得了上YTB的能力后，发现红名大佬的处理方法是这样的:</p>
<p>概率，和期望拆成两部分来做。</p>
<p>先算出概率。概率求起来是非常简单的。然后在概率的基础上求出期望来。</p>
<p>这应该算是两个dp数组了吧，感觉是非常神奇的操作。</p>
<p>在那基础上再进行简化就会变得非常简单，于是喜提AC:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 305</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> dp[MAXN][MAXN][MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; MAXN; ++k) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j + k &lt; MAXN; ++j) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i + j + k &lt; MAXN; ++i) &#123;</span><br><span class="line">                sum = i + j + k;</span><br><span class="line">                <span class="keyword">if</span> (!sum) <span class="keyword">continue</span>;</span><br><span class="line">                dp[i][j][k] += <span class="number">1.</span> * n / sum;  <span class="comment">// wait operations till hit 1, 2 or 3</span></span><br><span class="line">                <span class="keyword">if</span> (i) dp[i][j][k] += dp[i - <span class="number">1</span>][j][k] * (<span class="number">1.</span> * i / sum);  <span class="comment">// </span></span><br><span class="line">                <span class="keyword">if</span> (j) dp[i][j][k] += dp[i + <span class="number">1</span>][j - <span class="number">1</span>][k] * (<span class="number">1.</span> * j / sum);</span><br><span class="line">                <span class="keyword">if</span> (k) dp[i][j][k] += dp[i][j + <span class="number">1</span>][k - <span class="number">1</span>] * (<span class="number">1.</span> * k / sum);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">(<span class="keyword">int</span> I, <span class="keyword">int</span> J, <span class="keyword">int</span> K, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= I; ++i, <span class="built_in">putchar</span>(<span class="string">'\n'</span>)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= J; ++j, <span class="built_in">putchar</span>(<span class="string">'\n'</span>)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= K; ++k) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%.4lf "</span>, dp[i][j][k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, k;</span><br><span class="line">    i = j = k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n, temp;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> _ = <span class="number">0</span>; _ &lt; n; ++_) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;temp);</span><br><span class="line">        <span class="keyword">switch</span>(temp) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>: ++i; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>: ++j; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>: ++k; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>: <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    solve(n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.10lf\n"</span>, dp[i][j][k]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种大佬的直播视频感觉是非常有用的，像是他甚至说明了为什么三层循环的顺序是<code>k -&gt; j -&gt; i</code>。而对于自己思考来说可能很久都想不明白为什么。</p>
<h2 id="M-Candies"><a href="#M-Candies" class="headerlink" title="M - Candies"></a>M - Candies</h2><p>也许是入门级别的计数题? 感觉每次碰到计数题都很难受啊…</p>
<p>这道题就是告诉你有$n$个小朋友，第$i$个小朋友可以分配$[0, a_i]$个糖，一共$n$颗糖，必须全部分配完，问有几种分配方式。</p>
<p>一开始我是从小朋友开始dp的，于是就会出现类似于<em>当前状态取决于之前的小朋友分配到的糖果数</em>的尴尬情况。这样子的话完全没有办法化简状态。</p>
<p>最难的第一步就是定义dp状态。我们这里用的是<code>dp[i]</code>表示分配恰好$i$颗糖的方案数。</p>
<p>乍一看感觉根本走不通啊。可能这就是dp精妙的地方吧…</p>
<p>那么对于每个小朋友，如果我们已经分配了$\text{used}$颗糖，那么我们最多可以再给他分配$\min(a_i, k - \text{used})$颗糖。不妨记为分配了$\text{give}$颗糖，那么我们就可以给<code>dp[used + give]</code>加上<code>dp[used]</code>种分配方法。</p>
<p>考虑到我们一直在用比较小的值更新大的值（毕竟<code>used &lt; used + give</code>），所以我们应该从大到小进行更新，否则会导致一个值被更新多次的情况（比方说<code>dp[used] -&gt; dp[used + give] -&gt; dp[used + give + give]</code>）。</p>
<p>当前的复杂度是$\mathcal{O}(nK^2)$，考虑到$0 \le K \le 10^5$，肯定是不行的。</p>
<p>我们可以发现在分配糖的时候其实可以直接用一个差分数组来进行区间加，这样可以剪掉一个维度。</p>
<p>最后稍微注意一下其他的细节就可以了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// dp[i]: the number of ways to distribute i candies</span></span><br><span class="line"><span class="keyword">int</span> dp[N];</span><br><span class="line"><span class="keyword">int</span> dif[N];</span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span>&amp; a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    a += b;</span><br><span class="line">    <span class="keyword">if</span> (a &gt;= MOD) a -= MOD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span>&amp; a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    a -= b;</span><br><span class="line">    <span class="keyword">if</span> (a &lt; <span class="number">0</span>) a += MOD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">// only 1 way to distribute 0 candie</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a);</span><br><span class="line">        <span class="built_in">memset</span>(dif, <span class="number">0</span>, <span class="keyword">sizeof</span> dif);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> used = k; ~used; --used) &#123;</span><br><span class="line">            <span class="comment">// iterate the count of distributed candies</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// d: [1, min(a, k - used)]</span></span><br><span class="line">            <span class="comment">// use difference array to perform fast addition</span></span><br><span class="line">            <span class="keyword">int</span> L = used + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> R = used + min(a, k - used);</span><br><span class="line">            add(dif[L], dp[used]);</span><br><span class="line">            sub(dif[R + <span class="number">1</span>], dp[used]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> part_sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= k; ++j) &#123;</span><br><span class="line">            add(part_sum, dif[j]);</span><br><span class="line">            add(dp[j], part_sum);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dp[k]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;k)) &#123;</span><br><span class="line">        solve();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="N-Slimes"><a href="#N-Slimes" class="headerlink" title="N - Slimes"></a>N - Slimes</h2><p>入门级区间dp，但是自己还是非常不熟练。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">405</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// dp[l][r]: pair&lt;ll, ll&gt;: size of slime produced by merging [l, r], and cost of it.</span></span><br><span class="line">ll dp[N][N];</span><br><span class="line">ll a[N];</span><br><span class="line">ll prefix[N];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(ll&amp; a, ll b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b &lt; a) a = b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">sum</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> prefix[r] - prefix[l - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">63</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, a + i);</span><br><span class="line">        <span class="keyword">if</span> (i) prefix[i] = prefix[i - <span class="number">1</span>] + a[i];</span><br><span class="line">        <span class="keyword">else</span> prefix[i] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">0</span>; len &lt; n; ++len) &#123;</span><br><span class="line">        <span class="comment">// [l, r]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>, r = l + len; r &lt; n; ++l, ++r) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!len) &#123;</span><br><span class="line">                dp[l][r] = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> mid = l; mid + <span class="number">1</span> &lt;= r; ++mid) &#123;</span><br><span class="line">                    <span class="comment">// merge two slime [l, mid] and [mid + 1, r]</span></span><br><span class="line">                    update(dp[l][r], dp[l][mid] + dp[mid + <span class="number">1</span>][r] + sum(l, r));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// printf("%lld %lld\n", dp[0][n - 1].first, dp[0][n - 1].second);</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, dp[<span class="number">0</span>][n - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n)) &#123;</span><br><span class="line">        solve();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基本上里面的注释已经说的很明白了。</p>
<p>核心就是求出把$[l, r]$的所有史莱姆合并起来所需要的最少cost。</p>
<p>总的来说还是非常简单的。</p>
<h2 id="O-Matching"><a href="#O-Matching" class="headerlink" title="O - Matching"></a>O - Matching</h2><p>求配对总方案数，$1 \le N \le 21$，看起来就是状压。</p>
<p>可以当作二分图来看，男方一共$N$个节点，女方一共$N$个节点，如果$a_{i, j} = 1$那么说明这两个节点之间有一条边。现在求的是有多少种配对方案使得每个节点都与另外一个且只有一个节点匹配。</p>
<p>画出图来真的对思考很有帮助。我们假设<code>dp[i][mask]</code>表示到第$i$个男孩子为止，已经被匹配的女孩子是<code>mask</code>时的方案数。</p>
<p>那么<code>dp[i + 1][mask | (1 &lt;&lt; j)] += dp[i][mask]</code>，如果第$i$个男孩子与第$j$个女孩子匹配。当然这是有条件的: <code>mask &amp; (1 &lt;&lt; j) == 0</code>。</p>
<p>复杂度大概是$\mathcal{O}(n^2\cdot2^n)$。</p>
<p>还有一个剪枝就是如果<code>__builtin_popcount(mask) != i</code>的话也可以直接丢弃，因为这根本不能算是合法状态。这个不剪的话会TLE。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">21</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[N + <span class="number">1</span>][<span class="number">1</span> &lt;&lt; N];</span><br><span class="line"><span class="keyword">bool</span> a[N][N];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span>&amp; a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    a += b;</span><br><span class="line">    <span class="keyword">if</span> (a &gt;= MOD) a -= MOD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">// only one way to distribute 0 man and 0 women</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> mask = <span class="number">0</span>; mask &lt; (<span class="number">1</span> &lt;&lt; n); ++mask) &#123;</span><br><span class="line">            <span class="keyword">if</span> (__builtin_popcount(mask) != i) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!(mask &amp; (<span class="number">1</span> &lt;&lt; j)) &amp;&amp; a[i][j]) &#123;</span><br><span class="line">                    add(dp[i + <span class="number">1</span>][mask | (<span class="number">1</span> &lt;&lt; j)], dp[i][mask]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dp[n][(<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>, a[i] + j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        solve();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="P-Independent-Set"><a href="#P-Independent-Set" class="headerlink" title="P - Independent Set"></a>P - Independent Set</h2><p>树形dp，寒假时做的，已经不记得到底是怎么推出来的了。不过那时候我就能推出来，应该现在也能花点时间就推出来?</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[<span class="number">100005</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> cnt[<span class="number">100005</span>][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> par)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> white = <span class="number">1l</span>l, black = <span class="number">1l</span>l;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it : G[i]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (it != par) &#123;</span><br><span class="line">            dfs(it, i);</span><br><span class="line">            (white *= (cnt[it][<span class="number">0</span>] + cnt[it][<span class="number">1</span>])) %= MOD;</span><br><span class="line">            (black *= cnt[it][<span class="number">0</span>]) %= MOD;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cnt[i][<span class="number">0</span>] = white;</span><br><span class="line">    cnt[i][<span class="number">1</span>] = black;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y);</span><br><span class="line">        G[x].push_back(y);</span><br><span class="line">        G[y].push_back(x);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%I64d\n"</span>, (cnt[<span class="number">1</span>][<span class="number">0</span>] + cnt[<span class="number">1</span>][<span class="number">1</span>]) % MOD);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到那时的代码风格和现在还是有点不同的呀233。</p>
<h2 id="Q-Flowers"><a href="#Q-Flowers" class="headerlink" title="Q - Flowers"></a>Q - Flowers</h2><p>LCS变体，现在给定了花的高度和美丽程度，要求花的高度单增，求出取出的花的美丽度之和。</p>
<p>注意到$1 \le N \le 2 \times 10^5$，说明必须$\mathcal{O}(n \log n)$。</p>
<p>首先可以写出$\mathcal{O}(n^2)$的代码，其中对于<code>dp[i]</code>进行更新的时候，要找出在<code>dp[0]</code>到<code>dp[i - 1]</code>之间高度比它小的值里<code>dp</code>最大的值来。</p>
<p>于是我们可以用非递归线段树来进行优化。我们往每个叶子节点里存对应高度dp的值。每次进行区间查询，查询小于当前高度的值中的dp最大值。</p>
<p>然后就过了。简单粗暴。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="comment">// dp[i]: the maximum beauty value that you can achieve with flower [1, i]</span></span><br><span class="line">ll dp[N];</span><br><span class="line">ll h[N];</span><br><span class="line">ll a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">maximize</span><span class="params">(ll&amp; a, ll b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a &lt; b) a = b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span> &#123;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;ll&gt; tree;</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line"></span><br><span class="line">    explicit SegmentTree(): len(0) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        tree[i] = max(tree[i &lt;&lt; <span class="number">1</span>], tree[i &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        len = n;</span><br><span class="line">        tree.assign(len &lt;&lt; <span class="number">1</span>, <span class="number">0l</span>l);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> pos, ll new_val)</span> </span>&#123;</span><br><span class="line">        tree[pos + len - <span class="number">1</span>] = new_val;</span><br><span class="line">        <span class="keyword">for</span> (pos += len - <span class="number">1</span>; pos; pos &gt;&gt;= <span class="number">1</span>) maximize(tree[pos], new_val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ll <span class="title">query</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (l += len - <span class="number">1</span>, r += len; l &lt; r; l &gt;&gt;= <span class="number">1</span>, r &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l &amp; <span class="number">1</span>) maximize(ans, tree[l++]);</span><br><span class="line">            <span class="keyword">if</span> (r &amp; <span class="number">1</span>) maximize(ans, tree[--r]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it : tree) <span class="built_in">printf</span>(<span class="string">"%lld "</span>, it);</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        tree.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SegmentTree st;</span><br><span class="line">    st.build(n);</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        dp[i] = a[i]; <span class="comment">// at least we can choose only this flower</span></span><br><span class="line">        <span class="comment">// get the max dp value that height is smaller than the current one</span></span><br><span class="line">        ll max_dp = st.query(<span class="number">1</span>, h[i] - <span class="number">1</span>); </span><br><span class="line">        maximize(dp[i], max_dp + a[i]);</span><br><span class="line">        <span class="comment">// remember to update the segment tree</span></span><br><span class="line">        st.update(h[i], dp[i]);</span><br><span class="line">        maximize(ans, dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, h + i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i= <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, a + i);</span><br><span class="line">        &#125;</span><br><span class="line">        solve();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="R-Walk"><a href="#R-Walk" class="headerlink" title="R - Walk"></a>R - Walk</h2><p>求简单有向图中有多少条长度为$K$的路径。</p>
<p>这不就是无脑矩阵快速幂吗? 时间复杂度$\mathcal{O}(N^3\log K)$。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">55</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">ll n, k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span>&amp; a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    a += b;</span><br><span class="line">    <span class="keyword">if</span> (a &gt;= MOD) a -= MOD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mul</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (b) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) add(res, a);</span><br><span class="line">        add(a, a);</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> temp[N][N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a[N][N];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Matrix</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span> a);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>, a[i] + j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">identity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span> a);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) a[i][i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mul</span><span class="params">(<span class="keyword">const</span> Matrix&amp; b)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(temp, <span class="number">0</span>, <span class="keyword">sizeof</span> temp);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; ++k) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                    add(temp[i][j], ::mul(a[i][k], b.a[k][j]));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memcpy</span>(a, temp, <span class="keyword">sizeof</span> a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i, <span class="built_in">putchar</span>(<span class="string">'\n'</span>)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d "</span>, a[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pow</span><span class="params">(ll k)</span> </span>&#123;</span><br><span class="line">    Matrix a, res;</span><br><span class="line">    a.read();</span><br><span class="line">    res.identity();</span><br><span class="line">    <span class="keyword">while</span> (k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k &amp; <span class="number">1</span>) res.mul(a);</span><br><span class="line">        a.mul(a);</span><br><span class="line">        k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            add(ans, res.a[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>, &amp;n, &amp;k)) &#123;</span><br><span class="line">        <span class="built_in">pow</span>(k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>写的可以说是非常丑了。</p>
<h2 id="S-Digit-Sum"><a href="#S-Digit-Sum" class="headerlink" title="S - Digit Sum"></a>S - Digit Sum</h2><p>寒假就是被这题搞自闭的。当时的dp状态定义如下:</p>
<p><code>dp[i][j]</code>表示到第<code>i</code>位，和对$d$取模之后是<code>j</code>的方案数。</p>
<p>但是这有个非常致命的缺陷，就是没有办法判断是否超过了题目给定的N的大小。</p>
<p>后来看了Errichto的Stream才知道原来还需要一个维度，用于记录是否已经有某一位没有取到最大值。</p>
<p>有了这一维之后就会变得非常好推了:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e4</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[N][<span class="number">105</span>][<span class="number">2</span>];</span><br><span class="line"><span class="comment">// dp[i][j][k] means the count of numbers which at pos i, </span></span><br><span class="line"><span class="comment">// with sum of each digit modulo D equals to j</span></span><br><span class="line"><span class="comment">// if k == 1, then it hasn't chosen any digit that is smaller than k</span></span><br><span class="line"><span class="comment">// how to ensure all numbers in result is smaller than K?</span></span><br><span class="line"><span class="keyword">char</span> K[N];</span><br><span class="line"><span class="keyword">int</span> d;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span>&amp; a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    a += b;</span><br><span class="line">    <span class="keyword">if</span> (a &gt;= MOD) a -= MOD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = a - b;</span><br><span class="line">    <span class="keyword">if</span> (res &lt; <span class="number">0</span>) res += MOD;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (K[<span class="number">0</span>] == <span class="string">'1'</span> &amp;&amp; K[<span class="number">1</span>] == <span class="number">0</span> &amp;&amp; d == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"1\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; K[<span class="number">0</span>] - <span class="string">'0'</span>; ++i) dp[<span class="number">0</span>][i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">0</span>][K[<span class="number">0</span>] - <span class="string">'0'</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(K);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; max(d, <span class="number">10</span>); ++j) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">10</span>; ++k) &#123;</span><br><span class="line">                <span class="keyword">int</span> new_sum = (j + k) % d;</span><br><span class="line">                add(dp[i][new_sum][<span class="number">0</span>], dp[i - <span class="number">1</span>][j][<span class="number">0</span>]);</span><br><span class="line">                <span class="keyword">if</span> (k &lt; K[i] - <span class="string">'0'</span>) add(dp[i][new_sum][<span class="number">0</span>], dp[i - <span class="number">1</span>][j][<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">if</span> (k == K[i] - <span class="string">'0'</span>) add(dp[i][new_sum][<span class="number">1</span>], dp[i - <span class="number">1</span>][j][<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, sub((dp[len - <span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>] + dp[len - <span class="number">1</span>][<span class="number">0</span>][<span class="number">1</span>]) % MOD, <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; K[i]; ++i, <span class="built_in">putchar</span>(<span class="string">'\n'</span>)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= d; ++j) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%10d %10d "</span>, dp[i][j][<span class="number">0</span>], dp[i][j][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">"%s%d"</span>, K, &amp;d)) &#123;</span><br><span class="line">        solve();</span><br><span class="line">        <span class="comment">// debug();</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="T-Permutation"><a href="#T-Permutation" class="headerlink" title="T - Permutation"></a>T - Permutation</h2><p>看起来很难的一道题目，但是实际上仔细想一想就会发现实际上只需要记录最后一位的数值就可以了。</p>
<p>比方说，现在我们有<code>2 &lt; 3 &gt; 1</code>。</p>
<p>那么如果后一个符号是<code>&lt;</code>，那么我们可以取:</p>
<ul>
<li><code>2 &lt; 3 &gt; 1 &lt; 4</code></li>
<li><code>2 &lt; 3 &gt; 1 &lt; 3</code></li>
<li><code>2 &lt; 3 &gt; 1 &lt; 2</code></li>
</ul>
<p>但是后两个显然出现了重复数字啊！这样肯定是不行的。</p>
<p>有一个简单的解决方案，就是将已有permutation的数字里面，将所有大于等于最后一位的数字增加1就可以了。</p>
<p>比方说，<code>2 &lt; 3 &gt; 1 &lt; 3</code>就可以把<code>2 &lt; 3 &gt; 1</code>中大于等于<code>3</code>的数字增加1，变成<code>2 &lt; 4 &gt; 1 &lt; 3</code>。</p>
<p>同样的，<code>2 &lt; 3 &gt; 1 &lt; 2</code>就可以把<code>2 &lt; 3 &gt; 1</code>中大于等于<code>2</code>的数字增加1，变成<code>3 &lt; 4 &gt; 1 &lt; 2</code>。</p>
<p>另一个符号也是同理。</p>
<p>于是我们可以定义<code>dp[i][j]</code>表示到第<code>i</code>个位置，最后一位是<code>j</code>的permutation数。</p>
<p>然后就可以直接根据上面的方法写出递推式了，非常简单。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span>&amp; a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    a += b;</span><br><span class="line">    <span class="keyword">if</span> (a &gt;= MOD) a -= MOD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> p[N];</span><br><span class="line"><span class="keyword">int</span> dp[N][N];</span><br><span class="line"><span class="comment">// dp[i][j]: the count of permutations that with length i, </span></span><br><span class="line"><span class="comment">//           ending with j</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">// only one way to have permutation length 1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (p[i] == <span class="string">'&gt;'</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; ~j; --j) &#123;</span><br><span class="line">                add(cnt, dp[i - <span class="number">1</span>][j]);</span><br><span class="line">                add(dp[i][j], cnt);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; ++j) &#123;</span><br><span class="line">                add(dp[i][j], cnt);</span><br><span class="line">                add(cnt, dp[i - <span class="number">1</span>][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) add(ans, dp[n - <span class="number">1</span>][j]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i, <span class="built_in">putchar</span>(<span class="string">'\n'</span>)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%6d "</span>, dp[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">"%d%s"</span>, &amp;n, p + <span class="number">1</span>)) &#123;</span><br><span class="line">        solve();</span><br><span class="line">        <span class="comment">// debug();</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="U-Grouping"><a href="#U-Grouping" class="headerlink" title="U - Grouping"></a>U - Grouping</h2><p>最难的就是它可以把兔子分成好几组，看起来是状压又不是。在这里被卡住了。</p>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">首页</a></li>
         
          <li><a href="/archives/">文章</a></li>
         
          <li><a href="/about/">关于</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#AtCoder-Educational-DP"><span class="toc-number">1.</span> <span class="toc-text">AtCoder - Educational DP</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#D-01背包"><span class="toc-number">1.1.</span> <span class="toc-text">D - 01背包</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#空间复杂度优化"><span class="toc-number">1.1.1.</span> <span class="toc-text">空间复杂度优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#另一个优化"><span class="toc-number">1.1.2.</span> <span class="toc-text">另一个优化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#E-01背包变体"><span class="toc-number">1.2.</span> <span class="toc-text">E - 01背包变体</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#优化空间复杂度"><span class="toc-number">1.2.1.</span> <span class="toc-text">优化空间复杂度</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#F-Longest-Common-Substring"><span class="toc-number">1.3.</span> <span class="toc-text">F - Longest Common Substring</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#输出最长公共子序列"><span class="toc-number">1.3.1.</span> <span class="toc-text">输出最长公共子序列</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#G-Longest-Path"><span class="toc-number">1.4.</span> <span class="toc-text">G - Longest Path</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#H-Grid-1"><span class="toc-number">1.5.</span> <span class="toc-text">H - Grid 1</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#I-Coins"><span class="toc-number">1.6.</span> <span class="toc-text">I - Coins</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#J-Sushi"><span class="toc-number">1.7.</span> <span class="toc-text">J - Sushi</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#思考过程"><span class="toc-number">1.7.1.</span> <span class="toc-text">思考过程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#M-Candies"><span class="toc-number">1.8.</span> <span class="toc-text">M - Candies</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#N-Slimes"><span class="toc-number">1.9.</span> <span class="toc-text">N - Slimes</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#O-Matching"><span class="toc-number">1.10.</span> <span class="toc-text">O - Matching</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#P-Independent-Set"><span class="toc-number">1.11.</span> <span class="toc-text">P - Independent Set</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Q-Flowers"><span class="toc-number">1.12.</span> <span class="toc-text">Q - Flowers</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#R-Walk"><span class="toc-number">1.13.</span> <span class="toc-text">R - Walk</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#S-Digit-Sum"><span class="toc-number">1.14.</span> <span class="toc-text">S - Digit Sum</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#T-Permutation"><span class="toc-number">1.15.</span> <span class="toc-text">T - Permutation</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#U-Grouping"><span class="toc-number">1.16.</span> <span class="toc-text">U - Grouping</span></a></li></ol></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=https://medioqrity.github.io/2019/07/21/AtCoder-Educational-DP-Contest/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=https://medioqrity.github.io/2019/07/21/AtCoder-Educational-DP-Contest/&text=AtCoder Educational DP Contest"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https://medioqrity.github.io/2019/07/21/AtCoder-Educational-DP-Contest/&title=AtCoder Educational DP Contest"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https://medioqrity.github.io/2019/07/21/AtCoder-Educational-DP-Contest/&is_video=false&description=AtCoder Educational DP Contest"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=AtCoder Educational DP Contest&body=Check out this article: https://medioqrity.github.io/2019/07/21/AtCoder-Educational-DP-Contest/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=https://medioqrity.github.io/2019/07/21/AtCoder-Educational-DP-Contest/&title=AtCoder Educational DP Contest"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=https://medioqrity.github.io/2019/07/21/AtCoder-Educational-DP-Contest/&title=AtCoder Educational DP Contest"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=https://medioqrity.github.io/2019/07/21/AtCoder-Educational-DP-Contest/&title=AtCoder Educational DP Contest"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=https://medioqrity.github.io/2019/07/21/AtCoder-Educational-DP-Contest/&title=AtCoder Educational DP Contest"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=https://medioqrity.github.io/2019/07/21/AtCoder-Educational-DP-Contest/&name=AtCoder Educational DP Contest&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> 菜单</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> 目录</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> 分享</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> 返回顶部</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy; 2019 medioqrity
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">首页</a></li>
         
          <li><a href="/archives/">文章</a></li>
         
          <li><a href="/about/">关于</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
<link rel="stylesheet" href="/lib/justified-gallery/css/justifiedGallery.min.css">

    <!-- jquery -->
<script src="/lib/jquery/jquery.min.js"></script>
<script src="/lib/justified-gallery/js/jquery.justifiedGallery.min.js"></script>
<script src="/js/main.js"></script>
<!-- search -->

<!-- Google Analytics -->

<!-- Baidu Analytics -->

<!-- Disqus Comments -->


<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</body>
</html>
