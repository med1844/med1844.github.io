<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <!-- Math rendering -->
  <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async></script>
  <script type="text/x-mathjax-config">
  MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
  </script>
  
    <link rel="stylesheet" href="https://med1844.github.io/style.css">
  
  <script type="module">
    import {codeToHtml} from 'https://esm.sh/shiki@3.0.0'

    document.querySelectorAll('pre').forEach(async (pre) => {
      const lang = pre.getAttribute('data-lang')
      if (lang !== null) {
        const code = pre.textContent.trimEnd()
        pre.innerHTML = await codeToHtml(code, {
          lang: lang,
          theme: 'everforest-dark',
          colorReplacements: {
            '#2d353b': '#232a2e'
          }
        })
      }
    })
  </script>
</head>

<body>
  <section class="section">
    <div class="container">
      
<header id="page-header" class="header">
  <nav>
    <a href="/">Home</a>
    <a href="/about">About</a>
  </nav>
</header>
<h1 class="title">
  从零写一个编译器（三）- simpleJava Compiler
</h1>
<p class="date">2020-02-13</p>
<p>是时候来写真正的编译器了。</p>
<p>这并不是指一个simple的java compiler，而是一个名为simpleJava的语言的Compiler。</p>
<p>它会产生出合法的NASM代码，并交由NASM编译成<code>.obj</code>文件，最后由gcc链接成可执行文件。</p>
<p>不过在开始写这个编译器之前，由于我重写了Parser和Scanner，所以我认为有必要稍微简单说明一下新的结构。</p>
<h2 id="xin-parser-scanner">新Parser &amp; Scanner</h2>
<p>在利用上上篇文章写好的Parser来计算SimpleJava的CFG的Action和Goto表时，竟然花费了接近5分钟的时间才算出来:</p>
<p><img src="https://med1844.github.io/zh/build-a-compiler-3/runTimeOfLR1ItemSet.png" alt="runTimeOfLR1ItemSet" /></p>
<p>在设计CFG的早期阶段，引入任何一个新语法都可能导致CFG不再是LR(1)的。而引入新语法后，若真的不再是LR(1)，则又要加以分析并且修改。如果每次修改都要花费5分钟才能算出来，那按照我这个急性子可能这辈子都改不出心目中理想的CFG了。</p>
<p>另外，在复习LR(1)的过程中，我发现了自己以前设计上的失误，以及非常多可以加以改进的部分。</p>
<p>所以，比起干等，不如直接重写一份前端，将性能优化到极致。</p>
<h3 id="scanner">Scanner</h3>
<p>之前使用<code>Types.py</code>来定义，有三个坏处:</p>
<ul>
<li>所有的应用都要用同一个<code>Types.py</code>文件来定义，非常容易造成混乱</li>
<li>用于CFG分析中的displayName需要额外手动利用一个字典进行维护，非常麻烦</li>
<li>类型定义居然要用一个python类，而不是文件来描述?</li>
</ul>
<p>因此，我在新的Scanner中引入了<code>TypeDefinition</code>类，用于从文件中读取类型定义。每行定义一个类型，包含两个或三个元素（由两个空格分割），分别描述标准命名、匹配规则和显示命名。</p>
<p>有些不可能出现的元素，像是空格和注释，就不会有显示命名。因此只有两个元素。</p>
<p>另外，为了加速，所有的类型都会被映射成一个<code>int</code>。</p>
<p>根据上述描述，很容易写出新的<a href="https://github.com/medioqrity/newCompilerTest/blob/master/typeDef.py#L1">代码</a>。</p>
<p>接下来开始写Scanner。其实它就是Lexer，所以没什么好说的。不过这一次，我提供了<em>根据传递进来的类型过滤列表对输出结果进行过滤</em>的功能。这样也可以在更大程度上提供程序的灵活性:</p>
<pre data-lang="python" class="language-python "><code class="language-python" data-lang="python">import re
from typeDef import TypeDefinition


def parse(typeDef, src_code, filter_=None):
    &quot;&quot;&quot;
    return a list of Token object, generated by the input src_code
    if want to filter out any type of token, use filter.
    eg:
        parse(typedef, src, [&#x27;block_comment&#x27;, &#x27;line_comment&#x27;])
    &quot;&quot;&quot;
    assert isinstance(typeDef, TypeDefinition)
    result = []
    token_regex = typeDef.getRE()
    for mo in re.finditer(token_regex, src_code):
        if filter_ is None or mo.lastgroup not in filter_:
            id_ = typeDef.getID(mo.lastgroup)
            result.append((str(mo[0]), id_))
    result.append((&quot;$&quot;, &quot;$&quot;))
    return result


if __name__ == &quot;__main__&quot;:
    typedef = TypeDefinition.load(&quot;simpleJava&#x2F;typedef&quot;)
    with open(&quot;simpleJava&#x2F;test.sjava&quot;, &quot;r&quot;) as f:
        src_code = f.read()
    print(parse(typedef, src_code, [&#x27;space&#x27;]))

</code></pre>
<h3 id="parser">Parser</h3>
<p>首先来看看CFG的设计。与之前不同，终结符两边不用再用引号括起来了。这是基于一个简单的事实而作出的改动: <strong>终结符不可能出现在产生式左边。</strong> 因此，只要记录一下出现在产生式左侧的符号，以及所有符号，就能算出来哪些是非终结符了。</p>
<p>其次，CFG类将会承载更多的数据。为了说明这一点，先把目光转到LRItem这里。</p>
<p>这一次我抛弃了Grammar和Production类、转而只使用LRItem来描述。这是因为显然没有必要把同一个non-terminal能够产生的产生式强行放到一起的必要。计算LRItemSet的闭包，显然是以LRItem作为基本单位的，而不用像之前那样把Production和Grammar拆分了之后组成临时元组来当作基本单元。</p>
<p>此外，LRItem也可以改用更简洁的实现。先来说明一下LRItem的构造:</p>
<p><img src="https://med1844.github.io/zh/build-a-compiler-3/LRItem.png" alt="LRItem" /></p>
<p>很容易发现的一点是，Production是不可能在运行过程中改变的。既然如此，<strong>那为什么不用一个编号来取代掉没用的元组呢</strong>? 这样，既能节省空间，也能让运行效率变得更快。</p>
<p>如此一来，LRItem本质上就是个三元组了: <code>(int, int, set)</code>。而最后的<code>set</code>里，也只是存了一堆数字而已。</p>
<p>相比原来，应该算是减少了相当多没用的内存占用了吧。</p>
<h4 id="cfg">CFG</h4>
<p>为了支持将Production映射到ID的功能，有必要让CFG存储这样的映射。同样，由于需要计算sequence的first，所以需要获取sequence，因此需要提供根据ID返回sequence的功能。还有，在计算LRItemSet的自动机的时候，需要获取next，而先返回sequence再由外部取值实在是太慢且太繁琐。因此最好提供一个功能，根据给定的ID和位置，返回对应产生式对应位置的元素。这样明确之后不难写出<a href="https://github.com/medioqrity/newCompilerTest/blob/master/cfg.py">新的代码</a>。</p>
<h4 id="lritem">LRItem</h4>
<p>接下来是LRItem的设计。</p>
<p>尽管已经尽可能地简化了存储的数据，要对这些数据进行计算哈希值依然比较慢。这是因为展望符集合的存在: set是mutable对象，不能直接求hash。因此需要根据展望符集合生成一个列表并对这个列表进行排序后才能算出真正的hash来。显然排序和生成列表都是相对比较浪费时间的，因此采用一个<code>self.__hashVal</code>的变量，存储哈希值。这样，每个LRItem的hash值只会被计算一次。</p>
<p>另外，为了效率，照理说lookForward应该用拷贝构造函数，按照<code>self.lookForward = set(lookForward)</code>生成一个新的set，确保内部的数据不会被外部修改。然而，为了效率，内部直接保存外部传进来的引用是最快的，可以避免相当多没有必要的构造。这样就带来了一个挑战: 确保展望符集合不会在外部被修改。</p>
<p>基于上述优化的实现<a href="https://github.com/medioqrity/newCompilerTest/blob/master/cfg.py">在此</a>。</p>
<h4 id="lritemset">LRItemSet</h4>
<p>接下来考虑LRItemSet的设计。</p>
<p>鉴于LRItem已经包含了关于文法的全部信息，那么LRItemSet就真的只需要维护一个set就可以了。</p>
<p>话虽如此，还有不少可以改进的地方。首先，考虑到计算自动机时，LRItemSet经常需要计算hash。那么同样，可以仿照LRItem的方法，将hash值缓存下来，减少不必要的计算:</p>
<pre data-lang="python" class="language-python "><code class="language-python" data-lang="python">class LRItemSet:

    def __init__(self, cfg):
        # ...
        self.__needRecalculateHash = True  # lazy tag
        self.__hashVal = None

    def __hash__(self):
        if self.__needRecalculateHash:
            self.__hashVal = hash(tuple(sorted(list(self.items))))  # TIME COSTING
            self.__needRecalculateHash = False
        return self.__hashVal
</code></pre>
<p>另外，观察计算自动机时的BFS:</p>
<pre data-lang="python" class="language-python "><code class="language-python" data-lang="python">    while que:
        cur = que.popleft()
        if cur not in itemToID:
            itemToID[cur] = len(itemToID)
        for step in cur.getNext():
            nextItemSetCore = cur.goto(step, firstDict)  # get the core first
</code></pre>
<p><code>getNext</code>总是和<code>goto</code>联用。因此，我们可以在<code>getNext</code>中，记录一下<code>step</code>对应着哪些item:</p>
<pre data-lang="python" class="language-python "><code class="language-python" data-lang="python">    def getNext(self):
        &quot;&quot;&quot;
        get all possible out-pointing edges toward other LRItemSets.
        &quot;&quot;&quot;
        result = set()
        for item in self.items:
            step = item.get()
            if step is not None and step != &quot;&quot;:
                self.__map.setdefault(step, []).append(item)
                result.add(step)
        return result
</code></pre>
<p>这样，在获取<code>goto</code>的时候，可以避免多余的<code>if item.getNext() == step</code>这种判定。直接根据已经记录下来的映射关系，将这些item加进新的ItemSet里:</p>
<pre data-lang="python" class="language-python "><code class="language-python" data-lang="python">    def goto(self, step):
        &quot;&quot;&quot;
        return a new LRItemSet.
        &quot;&quot;&quot;
        result = LRItemSet(self.cfg)
        for item in self.__map[step]:
            result.addItem(item.gotoNext())
        return result
</code></pre>
<p>接下来来实现计算闭包。</p>
<p>为了避免再次出现上次那种还需要在updateClosure之后reduceForward的情况，这一次直接用<code>(productionID, dotPos)</code>作为键，建立一个字典，维护一个<code>tuple -&gt; set</code>的映射，<code>set</code>中存储lookForward集合。</p>
<p>仍然是BFS，但是这一次，在下一个字符是non-terminal，因而需要计算下一个LRItem的时候，可以稍微加速一点。</p>
<p>首先不难发现，需要加进队列中的LRItem，是由两层for产生的:</p>
<ul>
<li>遍历该non-terminal所能推导出的所有production</li>
<li>对于每个production，遍历所有可能出现的firstSet，将新production和firstSet组成新LRItem放入队列内。</li>
</ul>
<p>这样，很容易注意到，我们可以预先计算出当前产生式+每个展望符所能产生的所有新产生式$\forall i, \textbf{T} \to \cdots, \beta_0 \beta_1 , ... , \beta_n \gamma_i$。进而，我们可以预先计算出每个新产生式对应的first集合。这样，对于下一个non-terminal所能推导出的所有production，我们就不必重复计算first集了。</p>
<p>此外，计算sequence的first本身是非常耗时的一件事情。因此，可以利用字典加速: 存储已经计算过的sequence的first，避免重复计算。同时，也可以尽可能地减少set的数量，减少创建对象所需分配内存的时间。配合LRItem直接存引用，可以剩下相当多的内存和时间。</p>
<p>根据上述改进，不难写出<a href="https://github.com/medioqrity/newCompilerTest/blob/master/Parser.py#L205">代码</a>。</p>
<h4 id="lritemset-dfa">LRItemSet DFA</h4>
<p>接下来考虑自动机的计算。</p>
<p>既然计算闭包是非常费时间的，而又总是要算出闭包后才能判断当前项目集是否已经存在，因此还是老样子，利用字典进行加速:</p>
<pre data-lang="python" class="language-python "><code class="language-python" data-lang="python">if nextItemSetCore not in coreToClosure:
    coreToClosure[nextItemSetCore] = nextItemSetCore.calcClosure(firstDict)
nextItemSet = coreToClosure[nextItemSetCore]
</code></pre>
<p>计算goto的新核心是很快的。这样，将新核心映射到Closure的话，就可以将计算闭包的次数减少到$n$次。$n$代表该CFG对应的总状态数。</p>
<p>接下来的部分就几乎和之前没有任何区别了。代码请参阅<a href="https://github.com/medioqrity/newCompilerTest/blob/master/Parser.py#L299">这里</a>。</p>
<hr />
<p>到这里为止就没有什么再改进的必要了。同时也和之前写的ParseTree无缝对接上了，可喜可贺。在某种程度上也算是实现了模块化的设计吧。</p>
<p>进行了这么多用来加速的努力之后，来利用cProfile看一下结果吧！</p>
<p>首先是<code>simpleJavaCompiler.py</code>:</p>
<pre data-lang="python" class="language-python "><code class="language-python" data-lang="python">import ...

typedef = TypeDefinition.load(&quot;simpleJava&#x2F;typedef&quot;)
cfg = ContextFreeGrammar.load(typedef, &quot;simpleJava&#x2F;simpleJavaCFG&quot;)
action, goto = Parser.genActionGoto(typedef, cfg)
action.save(&#x27;simpleJava&#x2F;simpleJavaAction&#x27;)
goto.save(&#x27;simpleJava&#x2F;simpleJavaGoto&#x27;)
exit()
</code></pre>
<p>然后是<code>performanceProfiler.py</code>:</p>
<pre data-lang="python" class="language-python "><code class="language-python" data-lang="python">import cProfile, pstats, io
from pstats import SortKey

with open(&quot;simpleJavaCompiler.py&quot;, &quot;r&quot;) as f:
    src = f.read()

cProfile.run(src)
</code></pre>
<p>结果如下:</p>
<pre><code>         2166025 function calls (2165652 primitive calls) in 1.110 seconds

   Ordered by: standard name

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
                                      ...
   143867    0.051    0.000    0.051    0.000 Parser.py:107(__init__)
    50183    0.028    0.000    0.073    0.000 Parser.py:120(__hash__)
   136771    0.048    0.000    0.124    0.000 Parser.py:144(get)
      699    0.508    0.001    0.841    0.001 Parser.py:205(calcClosure)
    79974    0.019    0.000    0.019    0.000 Parser.py:221(&lt;listcomp&gt;)
        1    0.027    0.027    1.005    1.005 Parser.py:299(genActionGoto)
                                      ...
   136771    0.067    0.000    0.076    0.000 cfg.py:82(get)
    89771    0.013    0.000    0.013    0.000 cfg.py:97(getProduction)
                                      ...
   269204    0.022    0.000    0.022    0.000 {method &#x27;issubset&#x27; of &#x27;set&#x27; objects}
   141704    0.018    0.000    0.018    0.000 {method &#x27;setdefault&#x27; of &#x27;dict&#x27; objects}
                                      ...
</code></pre>
<p>注意到这一行:</p>
<pre><code>      699    0.508    0.001    0.841    0.001 Parser.py:205(calcClosure)
</code></pre>
<p>尽管做了那么多的努力，不过累计起来还是花掉了0.84秒用于计算闭包。可见，闭包的基础计算量真的相当大。</p>
<p>好在，相比之前647个状态算273.724秒，现在699个状态1.11秒就能算完，提升了266.417倍，也算是相当不错的成果了。</p>
<p>接下来就开始写真正的simpleJava吧。</p>
<h2 id="yu-yan-she-ji">语言设计</h2>
<p>从名字就能看出来，这个语言是简化版的java。确实如此。</p>
<p>除了python之外，我最喜欢的语言就是java了。此外，我也觉得C++很不错。然而，它们都有一些我不喜欢的地方。</p>
<p>在java中，所有代码都必须放在<code>public class ...</code>内来书写。就算是最简单的hello world也要声明一个类:</p>
<pre data-lang="java" class="language-java "><code class="language-java" data-lang="java">public class Main {
    public static void main(String[] args) {
        System.out.println(&quot;Hello world!&quot;);
    }
}
</code></pre>
<p>我不喜欢这样。所以，我希望simpleJava能够像python那样，可以把语句直接写在文件中，当作脚本使用。另外，java中不能重载运算符，这让我觉得很难接受。</p>
<p>另外一方面，python不像java那样每个变量的类型都几乎可以完全确定，尽管灵活，却总给人一种模糊的感觉。我也不喜欢。此外，像是numpy这种非常重要的第三方库的命名规范实在是令人作呕。而java中，至少所有的类名都是规范的。</p>
<p>而C++，语言特性太多，不同的库有不同的使用风格，跟拥有pythonic一称的python着实相去甚远。此外，引用虽然强大，能够实现swap等，但是不用特地标出来真的会舒服很多。 </p>
<p>因此，这多少算是python和java（可能还有C++）的混合体。</p>
<p>先来按照心目中的感觉，随便写一点代码。比方说，最大公约数，二分搜索:</p>
<pre><code>int gcd(int a, int b) {
    int temp;
    while (b) {
        temp = a % b;
        a = b;
        b = temp;
    }
    return b;
}

int binarySearch(int[] arr, int val) {
    &#x2F;**
     * given the array and the value, returns
     * the index of the val, or -1 if not found
     *&#x2F;
    for (int l = 0, r = len(arr); l &lt; r; ) {
        int mid = l + ((r - l) &gt;&gt; 1);
        if (arr[mid] == val) {
            l = r = mid;
        } else if (arr[mid] &lt; val) {
            mid = l + 1;
        } else {
            mid = r;
        }
    }
    &#x2F;&#x2F; assert l == r;
    return arr[l] == val ? l : -1;
}

int n = int(input());
int[] arr = new int[n];
for (int i = 0; i &lt; n; ++i) {
    arr[i] = int(input());
}

int m = int(input());
for (int i = 0; i &lt; m; ++i) {
    int query = int(input());
    result = binarySearch(arr, query);
    if (result == -1) {
        print(&quot;Key not found in array.&quot;);
    } else {
        print(&quot;Key found at &quot; + str(query));
    }
}
</code></pre>
<p>另外，我认为将<code>&amp;&amp;</code>换成<code>and</code>是个非常不错的改变。例如如下<a href="http://codeforces.com/problemset/problem/377/A">CF377A</a>的c++解:</p>
<pre data-lang="c++" class="language-c++ "><code class="language-c++" data-lang="c++">void dfs(int x, int y) {
    if (!k) return;
    for (int d = 0; d &lt; 4; ++d) {
        int nx = x + dx[d], ny = y + dy[d];
        if (0 &lt;= nx &amp;&amp; nx &lt; n &amp;&amp; 0 &lt;= ny &amp;&amp; ny &lt; m &amp;&amp; maze[nx][ny] == &#x27;.&#x27; &amp;&amp; !vis[nx][ny]) {
            vis[nx][ny] = 1;
            dfs(nx, ny);
            vis[nx][ny] = 0;
        }
    }
    if (!k) return;
    maze[x][y] = &#x27;X&#x27;;
    --k;
    return;
}
</code></pre>
<p>其中用于判断是否可以dfs的条件，应该可以在simpleJava中改写成如下形式:</p>
<pre><code>if (0 &lt;= nx and 0 &lt; n and 0 &lt;= ny and ny &lt; m and maze[nx][ny] == &#x27;.&#x27; and not vis[nx][ny]) {
    &#x2F;&#x2F; ...
}
</code></pre>
<p>几乎就是python的感觉了（笑）</p>
<ul>
<li>
<p>关于指针</p>
<p>其实我有一段时间相当喜欢指针和引用。但是说实话，果然还是Java写起来爽啊。所以还是删掉指针吧。</p>
</li>
<li>
<p>关于下标</p>
<p>python、Java、C++都是从0开始，左闭右开，Dijkstra也曾说明过这样做的理由，正巧我也非常认同。因此下标毫无疑问是从0开始的。 </p>
</li>
<li>
<p>关于切片</p>
<p>python的切片确实很爽，考虑之后加进去！</p>
</li>
</ul>
<h2 id="zhen-zheng-de-cfg">真正的CFG</h2>
<p>既然名为真正的CFG，就说明必然和理想中的文法有出入----事实上确实如此。</p>
<p>文法<a href="https://github.com/medioqrity/newCompilerTest/blob/master/simpleJava/simpleJavaCFG">在此</a>。</p>
<p>很可惜，没能做到<code>int[] arr;</code>这样的语法，妥协成了<code>int# arr;</code>。</p>
<p>这是因为:</p>
<pre><code>Type -&gt; BasicType Arrays
BasicType -&gt; id
Arrays -&gt; Arrays [ ] | [ ]
</code></pre>
<p>和:</p>
<pre><code>f1 -&gt; f1 [ f2 ]
f2 -&gt; Value
Value -&gt; id
</code></pre>
<p>导致的。在<code>BasicType -&gt; id</code>和<code>Value -&gt; id</code>需要被规约的时候，后面都会跟着<code>[</code>。此时就会产生<strong>规约-规约</strong>冲突。</p>
<p>想着<code>int* arr</code>也不错的样子，但是<code>*</code>作为指针的观念已然根深蒂固，最后还是用个全新的符号表示数组吧。</p>
<h2 id="jian-li-ast">建立AST</h2>
<p>首先要确定不同的节点应该怎么排列它的子节点。为此，我画了不少示意图:</p>
<p><img src="https://med1844.github.io/zh/build-a-compiler-3/stmtlAST.png" alt="stmtlAST" /></p>
<p><img src="https://med1844.github.io/zh/build-a-compiler-3/VarDecAST.png" alt="VarDecAST" /></p>
<p><img src="https://med1844.github.io/zh/build-a-compiler-3/funcDecAST.png" alt="funcDecAST" /></p>
<p><img src="https://med1844.github.io/zh/build-a-compiler-3/ifbAST.png" alt="ifbAST" /></p>
<p><img src="https://med1844.github.io/zh/build-a-compiler-3/forbAST.png" alt="forbAST" /></p>
<p><img src="https://med1844.github.io/zh/build-a-compiler-3/funcCallAST.png" alt="funcCallAST" /></p>
<p>之后就是给parse Tree的每个产生式规定一个文法，用于产生AST了。</p>
<p>给每个产生式都写一个规则实在是太可怕了...大致350多行，贴在博客里简直就是毁灭文章观感和浏览器渲染器的最佳选择。如果感兴趣的话请参阅<a href="https://github.com/medioqrity/newCompilerTest/blob/master/simpleJavaCompiler.py#L33">这里</a>。</p>
<p>结果，大致上长这样:</p>
<p><img src="https://med1844.github.io/zh/build-a-compiler-3/AST.png" alt="AST" /></p>
<p><img src="https://med1844.github.io/zh/build-a-compiler-3/AST3.png" alt="AST3" /></p>
<p>看起来非常庞大对吧? 然而相比之下，这已经比ParseTree不知道好到哪里去了...</p>
<h2 id="nasmyu-fa">NASM语法</h2>
<p>接下来要开始考虑IR的设计，以及最终的Code Generation了。考虑到接下来的IR设计，像是TAC序列、Code Block、控制流图等，应当尽可能地以方便生成目标代码作为主要目的，因而需要开始学习NASM。</p>
<p>第一个程序自然是不能免俗了。<del>虽然这习俗似乎还是从高级语言传过来的。</del></p>
<p><img src="https://med1844.github.io/zh/build-a-compiler-3/ASM.png" alt="ASM" /></p>
<h3 id="ji-cun-qi">寄存器</h3>
<p>刚上手的时候总归是真的非常凌乱。esp是啥? 为啥call了<code>_printf</code>之后要<code>add esp, 4</code>? push是啥? 为什么没有if else while这些关键字了?</p>
<p>先从寄存器开始吧。</p>
<p>对x86架构来说，有以下8个寄存器:</p>
<ul>
<li>EAX、EBX、ECX、EDX、ESP、EBP、ESI、EIP</li>
</ul>
<p>其中最经常被用到的大概就是EAX和EBX了。由于历史原因，EAX用于累加，EBX用于存基地址，ECX是计数器，EDX用于存放除法的余数。</p>
<p>当初我学到这里的时候非常好奇为什么要叫这么蹩脚的名字，后来去查了一下。它们中的X表示pair。这是因为早期电脑一次能处理的比特数只有8或者16位。要想获取寄存器A的低8位，就写AL。相应的，高8位就是AH。合起来，要使用整个16位的寄存器，就是AX了。后来，从16位拓展到32位后，就在AX前面加个E，代表Extend。64位则是RAX，不过这个R我就没能查到意思了。</p>
<p>话说回来，EAX这4个寄存器，到了今天似乎已经没什么专用的必要了。只要在call function的时候注意遵守约定即可。而相对应的，ESP和EBP至今依然有着特殊用途。</p>
<h3 id="zhan">栈</h3>
<p>ESP是用来保存当前栈顶的地址的，而EBP是用来保存当前帧的帧底地址的。</p>
<p>那么帧和栈是什么?</p>
<p>在一个程序运行的过程中，系统会为它开辟一片内存地址，用于存储变量等。而程序又会把这块空间分割为主要两部分:</p>
<p><img src="https://med1844.github.io/zh/build-a-compiler-3/RAMModel.png" alt="RAMModel" /></p>
<p>下面的stack就是栈了。</p>
<p>现在考虑如下代码:</p>
<pre data-lang="c" class="language-c "><code class="language-c" data-lang="c">int _add(int a, int b) {
    return a + b;
}

int main() {
    _add(3, 4);
    return 0;
}
</code></pre>
<p>如果我们处在第二行，那么栈中会存在这样两个帧:</p>
<p><img src="https://med1844.github.io/zh/build-a-compiler-3/RAMModel2.png" alt="RAMModel2" /></p>
<p>也就是说，一个函数运行时所临时占用的空间就算是帧了。</p>
<p>这样一来，也就很好理解递归爆深度的原因了:</p>
<p><img src="https://med1844.github.io/zh/build-a-compiler-3/stackOverFlow.png" alt="stackOverFlow" /></p>
<p>理解了栈的模型后，就很好理解push和esp了。</p>
<p>比方说，执行以下x86汇编代码:</p>
<pre data-lang="assembly" class="language-assembly "><code class="language-assembly" data-lang="assembly">push 893
</code></pre>
<p>机器就会把<code>893</code>放进栈里:</p>
<p><img src="https://med1844.github.io/zh/build-a-compiler-3/push.png" alt="push" /></p>
<p>鉴于893需要4个字节，所以ESP会减少4，而EBP不变。</p>
<p>所以，上面的hello world中，<code>add esp, 4</code>实际上等同于把栈中的指针给pop掉了。</p>
<h3 id="ji-ben-zhi-ling">基本指令</h3>
<p>光会push是不够的。</p>
<table><thead><tr><th>Assembly</th><th>C</th></tr></thead><tbody>
<tr><td><code>mov a, b</code></td><td><code>a = b</code></td></tr>
<tr><td><code>add a, b</code></td><td><code>a += b</code></td></tr>
<tr><td><code>push a</code></td><td></td></tr>
<tr><td><code>pop a</code></td><td></td></tr>
<tr><td><code>call a</code></td><td><code>a()</code></td></tr>
<tr><td><code>inc a</code></td><td><code>++a</code></td></tr>
</tbody></table>
<p>我想，知道了<code>add</code>，应该很容易能推出<code>sub</code>，<code>mul</code>等方法，所以这里省去了相当多的指令。</p>
<h3 id="han-shu-diao-yong">函数调用</h3>
<p>汇编里，<code>call a</code>就是调用函数<code>a</code>了。那么要怎么传递参数呢? 返回值又要怎么办呢?</p>
<p>这里就又要请esp和栈出场了。为</p>
<p>在调用函数前，<strong>逆序</strong>把数据push进栈中:</p>
<p><img src="https://med1844.github.io/zh/build-a-compiler-3/funcCall.png" alt="funcCall" /></p>
<p>之后<code>call _printf</code>即可。</p>
<p>以上数据均为真实数据。所用代码如下:</p>
<pre data-lang="assembly" class="language-assembly "><code class="language-assembly" data-lang="assembly">extern _printf
global _main

section .data
_a: db &quot;%s&quot;, 0
_b: db &quot;Hello&quot;, 0
_fmt: db &quot;%d %d&quot;, 0Ah, 0

section .text
_main:
    push _b
    push _a
    push _fmt
    call _printf
    add esp, 12
    push esp
    push ebp
    push _fmt
    call _printf
    add esp, 12
    mov eax, 0
    ret
</code></pre>
<p>输出结果如下:</p>
<p><img src="https://med1844.github.io/zh/build-a-compiler-3/runresult.png" alt="runresult" /></p>
<p>那么如果是自定义函数的话，要怎么利用栈中的参数呢?</p>
<p>很简单，利用<code>esp + offset</code>即可取值:</p>
<pre data-lang="assembly" class="language-assembly "><code class="language-assembly" data-lang="assembly">extern _printf
global _main

section .data
_fmt: db &quot;%d&quot;, 0Ah, 0
_a: dd 4
_b: dd 5

section .text
_add:
    mov eax, dword [esp + 4]
    mov ebx, dword [esp + 8]
    add eax, ebx
    ret

_main:
    push 4
    push 5
    call _add
    add esp, 8
    push eax
    push _fmt
    call _printf
    add esp, 8
    ret

</code></pre>
<p>神奇的是，windows上只需要偏移量+4即可，而网上的教程无一不是偏移量+8。而我也始终想不明白为什么windows只需要偏移量+4，难道不用存储PC的值和之前的EBP吗?</p>
<p>接下来是返回值。根据函数调用约定，似乎函数的返回值都是存在EAX内的。</p>
<p>因此，在调用函数前，最好先<code>push eax</code>，等<code>esp</code>清理完参数后，再恢复<code>eax</code>的值，避免意外被覆盖。</p>
<h2 id="ast">AST</h2>
<p>在开始写AST转ILOC的代码之前，先得实现AST。</p>
<p>AST本身和ParseTree非常像。唯一不同的是，ParseTree是根据每个节点的产生式序号映射属性文法动作的。而AST是根据预先定义的<code>actionID</code>来查找对应动作并执行的。</p>
<p>因此，很容易写出其<a href="https://github.com/medioqrity/newCompilerTest/blob/master/Ast.py">源码</a>。</p>
<h2 id="iloc">ILOC</h2>
<p>全称是Intermediate Language for Optimizing Compiler。然而我在开始写这个编译器的时候就知道，能写出来，并且写的正确，就足够了。我真的不奢求能做到什么优化。因此，尽管用了ILOC这个名字，却根本没有拿它做任何优化，也是多少有些奇葩了。</p>
<p>我认为，转换成高层次IR后再转换成NASM，尽管提供了添加代码优化的可能性，但所需要的代码量会更多，而我还希望给自己的寒假留下一些用在其他兴趣爱好上的时间。所以我决定直接从AST生成几乎就是直接可编译的NASM代码。</p>
<p>终于该开始写代码了！首先，为了能够看到输出，得先把<code>functionCall</code>给写好:</p>
<pre data-lang="python" class="language-python "><code class="language-python" data-lang="python">@aar.action(&quot;functionCall&quot;)
def _funcCall(funcCall, funcName, paramList):
    if str(funcName) in builtinFunctions:
        builtinFunctions[str(funcName)](paramList)
</code></pre>
<p>就是说，如果是内建函数，就直接调用内建函数来生成NASM代码。</p>
<p>simpleJava的打印叫<code>print</code>，因此先来实现它:</p>
<pre data-lang="python" class="language-python "><code class="language-python" data-lang="python">builtinFunctions = {}

def builtin(functionName):
    def decorate(function):
        builtinFunctions[functionName] = function
        return function
    return decorate

@builtin(&quot;print&quot;)
def _print(paramList):
    addEXTERN(&quot;_printf&quot;)
    fmtParam = []
    totSize = 0
    for param in paramList.getChilds()[::-1]:
        paramList.cb.addILOC(&quot;push&quot;, param.var.getOP())
        totSize += param.var.size
        type_ = param.var.type
        if type_ == &quot;int&quot;:
            fmtParam.append(&quot;%&quot; + &quot;d&quot;)
        elif type_ == &quot;String&quot;:
            fmtParam.append(&quot;%&quot; + &quot;s&quot;)
    fmtParam.reverse()
    fmtVarName = getTempVarName()
    addDATA(fmtVarName, &quot;db&quot;, &#x27;&quot;&#x27; + &quot; &quot;.join(fmtParam) + &#x27;&quot;&#x27; + &quot;, 0Ah, 0&quot;)
    paramList.cb.addILOC(&quot;push&quot;, fmtVarName)
    paramList.cb.addILOC(&quot;call&quot;, &quot;_printf&quot;)
    paramList.cb.addILOC(&quot;add&quot;, &quot;esp&quot;, str(totSize + 4))
</code></pre>
<p>总的来说，就是根据调用的参数的类型，生成格式化字符串，并且生成调用以及清理栈空间的代码。</p>
<p>最终的打印工作还是交给了printf来做，果然怎样都绕不开C语言啊（笑）</p>
<p>这里采用的是<code>xxx.cb.addILOC()</code>的方法来添加ILOC，其中的<code>cb</code>是当前节点所属的代码块。代码块是在实现了<code>if else while for</code>等结构化流程控制语句之后的产物，所以会之后讲。</p>
<p>写完之后运行的效果如下:</p>
<p><img src="https://med1844.github.io/zh/build-a-compiler-3/HelloSimpleJava.png" alt="HelloSimpleJava" /></p>
<p>只能打印数字和字符串是远远不够的。起码得能打印变量吧? 因此，先把变量声明给写了:</p>
<pre data-lang="python" class="language-python "><code class="language-python" data-lang="python">@aar.action(&quot;varDec&quot;, index=0)
def _varDec(varDec, type_, idList):
    for node in idList.getChilds():
        node.dec = True
        node.type = type_.getContent()
        node.isArray = type_.isArray
        node.dim = type_.dim

@aar.action(&quot;id_var&quot;)
def _id_var(id_):
    varName = &quot;__v_%d_%d_%s&quot; % (id_.ns[0], id_.ns[1], id_.getContent())
    if &quot;dec&quot; in id_:
        if id_.type[0].islower():
            id_.var = Variable(varName, id_.type, id_.ns)
    else:
        ns = id_.ns
        while True:
            tempVarName = &quot;__v_%d_%d_%s&quot; % (ns[0], ns[1], id_.getContent())
            if tempVarName in declaredVars[ns]:
                id_.var = declaredVars[ns][tempVarName]
                break
            if ns not in nsInheritance:
                print(&quot;[ERROR] Undefined variable: %s has not been declared yet.&quot; % varName)
                exit()
            ns = nsInheritance[ns]
</code></pre>
<p>通过<code>Variable</code>类，可以统一地管理变量对象所具有的name, size, type, namespace等属性。namespace也是引入if else while之后的内容，之后再说明。</p>
<p>之后，把<a href="https://github.com/medioqrity/newCompilerTest/blob/master/simpleJavaCompiler.py#L710">变量的运算</a>给写好:</p>
<pre data-lang="python" class="language-python "><code class="language-python" data-lang="python">@aar.action(&quot;assign&quot;)
def _assign(assg, l, r): pass

@aar.action(&quot;add&quot;)
def _add(add, l, r): pass

...

@aar.action(&quot;sub&quot;)
def _sub(sub, l, r): pass

@aar.action(&quot;imod&quot;)
def _imod(imod, l, r): pass
</code></pre>
<p>以上是算术运算。接下来，需要实现条件运算，也就是<code>a == b</code>，<code>not (a or b)</code>之类的。</p>
<p>我决定把条件运算的返回值设定为int。不过这样就引出了一个问题: NASM中，用于比较的<code>cmp</code>的结果只会存放在CPU的flags寄存器中。</p>
<p>上网查了一下，有个叫LAHF的神奇指令，可以把CPU flags寄存器的值搬到AH，也就是EAX的第8 ~ 15比特。</p>
<p>鉴于<code>cmp a, b</code>实际上是<code>a - b</code>，然后把结果存入寄存器中。因此，若<code>a == b</code>，则相减结果为0，导致Zero Flag被设为1。由于Zero Flag是AH的第7位，因此不难得出应该左移8 + (7 - 1) = 14位，再与1做与操作，就能得到int类型的结果了。<code>ne</code>类似，只需要多加一步<code>xor eax, 1</code>反转答案即可。</p>
<p><code>a &lt; b</code>是利用Sign Flag，即正负号的标记。若是1则说明是负数。因此，<code>cmp a, b</code>后，若SF是1，则说明<code>a - b &lt; 0</code>，即<code>a &lt; b</code>。鉴于SF是AH最高的第8位，因此需要左移15位再与1做与操作才能得到int类型的结果。</p>
<p><code>a &gt;= b</code>则正好处在<code>a &lt; b</code>的反面。因此，只需要复制<code>a &lt; b</code>的代码，多加一步<code>xor eax, 1</code>即可。</p>
<p><code>&gt;</code>和<code>&lt;=</code>同理。</p>
<p>于是就很好<a href="https://github.com/medioqrity/newCompilerTest/blob/master/simpleJavaCompiler.py#L850">实现</a>了。</p>
<p>这样生成的代码会非常的臃肿，经常会有<code>pop ebx</code>下一句就是<code>push ebx</code>的情况。但是----哎，既然前面做了想要尽快完成代码的决定，那... <del>大概也就可以心安理得地划水不好好考虑优化了吧</del>。</p>
<h2 id="dai-ma-kuai">代码块</h2>
<p>接下来该开始写流程控制语句了。先来把代码块类写好:</p>
<pre data-lang="python" class="language-python "><code class="language-python" data-lang="python">class CodeBlock:

    def __init__(self, name):
        self.name = name
        self.list = []
        self.next = None
        self.segment = []
    
    def addILOC(self, op, *l):
        self.list.append((op, *l))
</code></pre>
<p>显而易见的是，每个<code>statementList</code>都会对应着一块全新的代码块，因此写个简单地动作注册器，生成cb:</p>
<pre data-lang="python" class="language-python "><code class="language-python" data-lang="python">firstAAR = ASTActionRegister()
@firstAAR.action(&quot;stmtList&quot;, index=0)
def _stmtl(stmtl, *rest):
    stmtl.cb = CodeBlock(getNewCodeBlockName())
ast.evaluate(firstAAR)
</code></pre>
<p>再把位于stmtl节点上的所有cb下推到所有节点，注意不要覆盖子节点的cb:</p>
<pre data-lang="python" class="language-python "><code class="language-python" data-lang="python">def updateCB(cur, childs):
    for child in childs:
        if &quot;cb&quot; not in child:
            child.cb = cur.cb
        child.run(updateCB)
ast.run(updateCB)
</code></pre>
<h2 id="liu-cheng-kong-zhi-yu-ju">流程控制语句</h2>
<p>终于开始写流程控制语句了。就像是刚学编程那会一样，慢慢掌握复杂的语法。只不过这一次，要把掌握换成实现。</p>
<p>大家都知道，if之类的语句，就是判断如果正确就跳到内部的代码块去执行，完事再跳回来。</p>
<p>的确如此。跳到内部代码块不难，只需要<code>cmp + jz</code>的组合即可。但是，<strong>要怎么跳回来呢</strong>?</p>
<p>显然，只能在每个if对应的代码块里，追加上<code>jmp ...</code>，跳到if后面的代码块。这样一来，就势必要把if后面的语句块拆开来，当作新的代码块来处理了:</p>
<p><img src="https://med1844.github.io/zh/build-a-compiler-3/Segmentation2.png" alt="Segmentation2" /></p>
<p>while也是同理:</p>
<p><img src="https://med1844.github.io/zh/build-a-compiler-3/Segmentation.png" alt="Segmentation" /></p>
<p><em>上图分别把<code>print(&quot;half life 3!!!&quot;)</code>和<code>print(&quot;wow&quot;)</code>划分成了新的代码块。</em></p>
<p>看起来很简单。但是，在用AST生成ILOC的时候，却不能直接确定下一个代码块是哪个。以上面的while作为例子:</p>
<p><img src="https://med1844.github.io/zh/build-a-compiler-3/gotoWhere.png" alt="gotoWhere" /></p>
<p>为了说明方便起见，假定临时变量<code>__t = (c != 0)</code>。在求完<code>__t</code>的值之后，就应该根据它的值，确定是继续往下执行stmtList中的语句，还是直接跳到后面的functionCall。</p>
<p>先写上判断:</p>
<pre data-lang="assembly" class="language-assembly "><code class="language-assembly" data-lang="assembly">mov eax, dword [__t]
cmp eax, 0
jz ...
</code></pre>
<p>上面的代码先从内存中取出<code>__t</code>的值，放到寄存器<code>eax</code>中。之后，通过<code>cmp</code>，执行<code>eax - 0</code>，并将结果存放在CPU的flag中。之后，<code>jz</code>是指，如果zero flag是1，也就是说<code>eax - 0 == 0</code>，则<code>jmp</code>到...</p>
<p><code>jmp</code>到哪呢? 这需要获取<strong>父节点的兄弟节点</strong>的数据...实在是不怎么现实。而且，此时这个兄弟节点还没被划分成新的代码块。即便将父节点的兄弟节点的代码块修改成了新生成的代码块，那还需要把这个兄弟节点之后的每个节点的代码块都改成新的。若是出现了很多个平行的while块，用脚想都知道是$\mathcal{O}(n^2)$的复杂度。再怎么不考虑编译器的速度也不能采用这么脏的实现啊。</p>
<p>是不是可以通过一遍后序遍历把每个节点代码块后面会跟着的代码块提前算出来呢? 很遗憾，也许是因为太久没有做过树形dp，我想了很久都没有发现对任意节点都通用的情况。</p>
<p>所以，我想最好的办法还是先不写判断，用伪指令<code>if cond, val, codeblock</code>来表示如果<code>cond == val</code>则跳转到<code>codeblock</code>，否则继续向下执行。</p>
<p>这样做的好处大概是，<code>if</code>可以被重复使用。也就是说，if语法块可以利用<code>if</code>指令描述，while语法块也可以利用<code>if</code>语法块描述，<code>for</code>同理。</p>
<p>在if块结束之后，添加一条指令，跳转到if语法块后面的部分。由于这个后面的部分要等到整颗AST都遍历完后才能确定，所以现在就只用一个元组代表需要之后再计算即可。</p>
<p>实现<a href="https://github.com/medioqrity/newCompilerTest/blob/master/simpleJavaCompiler.py#L974">在此</a>。</p>
<pre data-lang="python" class="language-python "><code class="language-python" data-lang="python">@aar.action(&quot;ifBlock&quot;)
def _ifBlock(ifb, *childs):
    for i in range(1, len(childs), 2):
        c0, sl = childs[i - 1], childs[i]
        ifb.cb.addILOC(&quot;if&quot;, c0.var, &quot;1&quot;, sl.cb, (&quot;cur&quot;, &quot;next&quot;))

# ...

@aar.action(&quot;whileBlock&quot;)
def _while(while_, c0, sl):
    sl.cb.next = (while_.cb, &quot;next&quot;)
    while_.cb.addILOC(&quot;goto&quot;, sl.cb)
    sl.cb.addILOC(&quot;goto&quot;, sl.cb)

# ...
</code></pre>
<p>那么这个<code>(cb, &quot;next&quot;)</code>和<code>(&quot;cur&quot;, &quot;next&quot;)</code>要怎么计算呢?</p>
<p>首先，根据<code>goto</code>指令，分割语法块。这是显而易见的: <code>goto</code>到其他程序段后，后面的代码自然不可能执行，除非从别的语法块跳回来。因此，可以写出如下代码:</p>
<pre data-lang="python" class="language-python "><code class="language-python" data-lang="python">class CodeBlock:
    def calcSegment(self):
        self.segment.clear()
        segCount = 0
        for op, *_ in self.list:
            self.segment.append(segCount)
            if op == &quot;goto&quot;:
                segCount += 1
    
    def getSegments(self):
        self.calcSegment()
        newCBs = [self] + [CodeBlock(self.name + &quot;_SEG_%d&quot; % i) for i in range(1, self.segment[-1] + 1)]
        for i in range(len(self.list)):
            if self.segment[i]:
                newCBs[self.segment[i]].addILOC(*self.list[i])
        i = len(self.list) - 1
        while self.segment[i]:
            self.list.pop()
            i -= 1
        for i in range(len(newCBs) - 1):
            l, r = newCBs[i], newCBs[i + 1]
            l.next = r
        return newCBs

cbs = {EXIT_BLOCK}
def getCB(cur, *childs):
    cbs.add(cur.cb)
ast.apply(getCB)

# split code blocks by goto
que = deque(cbs)
while que:
    cb = que.pop()
    segmentation = cb.getSegments()
    for i in range(1, len(segmentation)):
        cbs.add(segmentation[i])
        que.append(segmentation[i])
</code></pre>
<p>在分割的过程中，可以计算出被分割各块的next:</p>
<pre data-lang="python" class="language-python "><code class="language-python" data-lang="python">        for i in range(len(newCBs) - 1):
            l, r = newCBs[i], newCBs[i + 1]
            l.next = r
</code></pre>
<p>分割完后，不可能再更改每条语句所属的代码块，因此可以在此时把<code>&quot;cur&quot;</code>替换成代码块对象的引用:</p>
<pre data-lang="python" class="language-python "><code class="language-python" data-lang="python">    def updateCur(self):
        for i, (_, *rest) in enumerate(self.list):
            self.list[i] = list(self.list[i])
            for j in range(len(rest)):
                if isinstance(rest[j], tuple):
                    if isinstance(rest[j][0], str) and rest[j][0] == &quot;cur&quot;:
                        self.list[i][j + 1] = (self, rest[j][1])
</code></pre>
<p>之后，扫描所有产生的代码。根据<code>if</code>和<code>goto</code>伪指令内要跳转到的元组，建立代码块之间的依赖图。还请注意，如果A需要B的next，那么就从<code>(B, &quot;next&quot;)</code>连一条边到<code>A</code>。这样反直觉的连法是为了之后利用拓扑排序，将所有<code>(cb, &quot;next&quot;)</code>这样未定的元组替换为确定的<code>CodeBlock</code>对象。</p>
<pre data-lang="python" class="language-python "><code class="language-python" data-lang="python"># If A would like to goto B.next, we have to calculate
# B.next first before calculate A.
# If A.next is (B, next), then we have to calculate
# B.next before calculate CB that containing A.next.
nextDependency = {}
indeg = {k: 0 for k in cbs}

for cb in cbs:
    if isinstance(cb.next, tuple):
        nextDependency.setdefault(cb.next, []).append((cb, &quot;next&quot;))
        indeg[cb.next] = 0
        indeg[(cb, &quot;next&quot;)] = 0
    for op, *_ in cb:
        if op == &quot;goto&quot;:
            dest = _[0]
            if isinstance(dest, tuple):
                nextDependency.setdefault(dest, []).append(cb)
                indeg[dest] = 0
                indeg[cb] = 0
        elif op == &quot;if&quot;:
            lop, rop, dest = _
            if isinstance(dest, tuple):
                nextDependency.setdefault(dest, []).append(cb)
                indeg[dest] = 0
                indeg[cb] = 0
</code></pre>
<p>然后应用拓扑排序:</p>
<pre data-lang="python" class="language-python "><code class="language-python" data-lang="python">for k, v in nextDependency.items():
    for dest in v:
        indeg[dest] += 1

# toposort
que = deque(k for k in indeg if not indeg[k])
while que:
    cur = que.pop()
    if isinstance(cur, tuple):
        cur[0].updateNext()
    else:
        cur.updateNext()
    if cur in nextDependency:
        for v in nextDependency[cur]:
            if v not in indeg:
                que.append(v)
            indeg[v] -= 1
            if not indeg[v]:
                que.append(v)
</code></pre>
<p>其中，<code>updateNext()</code>方法会扫描当前cb中所有语句中的所有参数，并将所有未定的代码块对象替换成已经计算好的代码块对象。显然，当<code>cur</code>被弹出双出队列时，说明它已经没有入边，也就是说它的所有依赖已经被计算好了，因此可以放心的调用<code>updateNext</code>方法。该方法实现如下:</p>
<pre data-lang="python" class="language-python "><code class="language-python" data-lang="python">class CodeBlock:

    def updateNext(self):
        # update operands containing next of other CB
        if isinstance(self.next, tuple):
            self.next = self.next[0].next
        for i, (_, *rest) in enumerate(self.list):
            self.list[i] = list(self.list[i])
            for j in range(len(rest)):
                if isinstance(rest[j], tuple):
                    self.list[i][j + 1] = self.list[i][j + 1][0].next
</code></pre>
<p>最后，把<code>goto</code>和<code>if</code>伪指令替换成真正可执行的NASM语句:</p>
<pre data-lang="python" class="language-python "><code class="language-python" data-lang="python"># change if and goto to jz and jmp
for cb in cbs:
    for i, (op, *rest) in enumerate(cb):
        cb.list[i] = list(cb.list[i])
        if op == &quot;goto&quot;:
            cb.list[i][0] = &quot;jmp&quot;
            if cb.list[i][1] is None:
                cb.list[i][1] = EXIT_BLOCK
            ControlFlowGraph.setdefault(cb, []).append(cb.list[i][1])
        elif op == &quot;if&quot;:
            c0, const, st = rest
            if st is None:
                st = EXIT_BLOCK
            cb.list[i] = [
                [&quot;push&quot;, &quot;ebx&quot;],
                [&quot;mov&quot;, &quot;ebx&quot;, c0.getOP()],
                [&quot;cmp&quot;, &quot;ebx&quot;, const],
                [&quot;pop&quot;, &quot;ebx&quot;],
                [&quot;jz&quot;, st]
            ]
            ControlFlowGraph.setdefault(cb, []).append(st)
</code></pre>
<p>这里，<code>ControlFlowGraph</code>是用来确定哪些代码块是不会跳转到其他任何代码块的。这些代码块需要在末尾添加跳转到<code>_exit</code>代码段的指令，否则就会跨过代码段的间隔，继续向下执行。</p>
<p>简单地求一下ControlFlowGraph各顶点的出边数，出边为0就添加<code>jmp _exit</code>即可。</p>
<pre data-lang="python" class="language-python "><code class="language-python" data-lang="python"># check cb that need jmp to _exit
outdeg = {}
for src, dests in ControlFlowGraph.items():
    outdeg[src] = len(dests)
    for dest in dests:
        if dest not in outdeg:
            outdeg[dest] = 0

for k, v in outdeg.items():
    if not v:
        k.addILOC(&quot;jmp&quot;, EXIT_BLOCK)
</code></pre>
<p>最后打印语句，即可获得输出:</p>
<pre data-lang="python" class="language-python "><code class="language-python" data-lang="python">for ex in EXTERN:
    print(&quot;extern %s&quot; % ex)
print(&quot;global _main&quot;)
print(&quot;\nsection .data&quot;)
print(&quot;\n&quot;.join(DATA))
print(&quot;\nsection .bss&quot;)
print(&quot;\n&quot;.join(BSS))
print(&quot;\nsection .text&quot;)
for cb in cbs:
    print(&quot;%s:&quot; % cb.name)
    for line in cb:
        if not isinstance(line[0], list):
            print(&quot;    %s %s&quot; % (str(line[0]), &quot;, &quot;.join(str(_) for _ in line[1:])))
        else:
            for l in line:
                print(&quot;    %s %s&quot; % (str(l[0]), &quot;, &quot;.join(str(_) for _ in l[1:])))
</code></pre>
<p>以这段代码作为输入例:</p>
<p><img src="https://med1844.github.io/zh/build-a-compiler-3/if_while_test.png" alt="if_while_test" /></p>
<p>会产生这样的输出:</p>
<p><img src="https://med1844.github.io/zh/build-a-compiler-3/if_while_test_result.png" alt="if_while_test_result" /></p>
<h2 id="continue-break">Continue &amp; Break</h2>
<p>考虑如下输入:</p>
<pre data-lang="C" class="language-C "><code class="language-C" data-lang="C">int c = 10;
print(&quot;Rocket Launch Countdown...&quot;);
while (c != 0) {
    --c;
    if (c == 7) {
        print(&quot;seven&quot;);
        continue;
    } else if (c == 3) {
        for (int i = 0; i &lt; 3; ++i) {
            print(&quot;Count Down Interrupted!!&quot;);
        }
        break;
    }
    print(c);
}
print(&quot;BOOOOM!!!&quot;);

</code></pre>
<p>可以看得出来，不论是<code>continue</code>，还是<code>break</code>，都需要跳转到它们所属的<code>statementBlock</code>之外:</p>
<p><img src="https://med1844.github.io/zh/build-a-compiler-3/continueAndBreak_Flow.png" alt="continueAndBreak_Flow" /></p>
<p>因此，需要设定两个全新的属性: loopBlock和breakBlock，分别说明如果接下来出现了continue和break，则分别应该往哪个block的起点或哪个block的nextBlock跳转:</p>
<pre data-lang="python" class="language-python "><code class="language-python" data-lang="python">def updateBreakBlock(cur, childs):
    for child in childs:
        child.bb = cur.bb
        child.run(updateBreakBlock)

def updateContinueBlock(cur, childs):
    for child in childs:
        child.lb = cur.lb
        child.run(updateContinueBlock)

@aar.action(&quot;whileBlock&quot;, index=1)
def _while_1(while_, c0, sl):
    sl.lb = sl.cb
    sl.run(updateContinueBlock)
    sl.bb = while_.cb
    sl.run(updateBreakBlock)
    sl.cb.addILOC(&quot;if&quot;, c0.var, &quot;0&quot;, (while_.cb, &quot;next&quot;))
</code></pre>
<p>这样，<code>sl.lb = sl.cb</code>，那么不论处在多深的嵌套中，只要没有被其他更深层的while覆盖，那么<code>continue</code>依然可以正常的跳转到<code>sl</code>的起点，而<code>sl.bb = while_.cb</code>则可以让<code>break</code>跳转到<code>while_.cb</code>的下一个代码块:</p>
<pre data-lang="python" class="language-python "><code class="language-python" data-lang="python">@aar.action(&quot;break&quot;)
def _break(break_):
    break_.cb.addILOC(&quot;goto&quot;, (break_.bb, &quot;next&quot;))

@aar.action(&quot;continue&quot;)
def _continue(continue_):
    continue_.cb.addILOC(&quot;goto&quot;, continue_.lb)
</code></pre>
<p>由于之前已经写好了对<code>goto</code>和<code>if</code>伪指令的操作，因此除了添加上面几个简单的函数之外，无需任何改变就可以实现continue和break了，可喜可贺。</p>
<p>编译上面的迫真火箭发射程序并运行可以获得如下结果:</p>
<p><img src="https://med1844.github.io/zh/build-a-compiler-3/continueAndBreak.png" alt="continueAndBreak" /></p>
<h2 id="han-shu-sheng-ming">函数声明</h2>
<p>之前已经说明过了函数该如何调用。因此，接下来就只需要实现函数的声明，以及根据函数声明产生调用代码就可以了。</p>
<p>首先，就像是<code>Variable</code>类一样，设定一个<code>Function</code>类，用来记录返回值，标识符，参数列表和语句列表。</p>
<pre data-lang="python" class="language-python "><code class="language-python" data-lang="python">declaredFunctions = {}

class Function:

    def __init__(self, returnType, name, parameters, sl):
        self.returnType = returnType
        self.name = name
        self.parameters = parameters
        self.sl = sl
    
    def __str__(self):
        return &quot;%s(%s)&quot; % (self.name, &quot;, &quot;.join(&quot;%s %s&quot; % (var.type, var.name) for var in self.parameters))

    def __repr__(self):
        return repr(str(self))
</code></pre>
<p>之后，只需要在<code>funcDec</code>节点执行创建函数的操作即可:</p>
<pre data-lang="python" class="language-python "><code class="language-python" data-lang="python">@aar.action(&quot;defParam&quot;)
def _defParam(defp, type_, id_):
    varName = &quot;__v_%d_%d_%s&quot; % (id_.ns[0], id_.ns[1], id_.getContent())
    if type_.getContent()[0].islower():
        defp.var = Variable(varName, type_.getContent(), defp.ns)

@aar.action(&quot;defParamList&quot;)
def _defParamList(defpl, *defps):
    defpl.list = [_.var for _ in defps]

@aar.action(&quot;funcDec&quot;, index=0)
def _funcDec_0(func, type_, func_id, defpl, sl):
    defpl.ns = sl.ns
    defpl.run(updateNS)

@aar.action(&quot;funcDec&quot;)
def _funcDec(func, type_, func_id, defpl, sl):
    funcName = str(func_id.getContent())
    declaredFunctions[funcName] = \
        Function(
            str(type_.getContent()),
            funcName,
            defpl.list,
            sl.cb
        )
</code></pre>
<p>不过，到了这里，就开始涉及到严重的问题了:</p>
<p><strong>变量的作用域还没有设定</strong>。</p>
<p>因此，需要引入作用域。由于对作用域和命名空间的认知有些混乱，之后可能会交叉使用这两个名字。</p>
<p>一个非常简单的想法就是，作用域由两个数字来描述，分别是:</p>
<ul>
<li>嵌套深度</li>
<li>在该深度下是第几个代码块</li>
</ul>
<p>考虑到每个statementList都会产生新的代码块，所以只需要利用一个简单的函数就可以实现:</p>
<pre data-lang="python" class="language-python "><code class="language-python" data-lang="python">depth = -1
count = {}  # depth: count
def initNS(cur, childs):
    global depth
    if cur.getContent() == &quot;stmtList&quot;:
        depth += 1
        if depth not in count:
            count[depth] = -1
        count[depth] += 1
        cur.ns = (depth, count[depth])
        for child in childs:
            child.run(initNS)
        depth -= 1
    else:
        cur.ns = (depth, count[depth])
        for child in childs:
            child.run(initNS)
    declaredVars[cur.ns] = {}
ast.run(initNS)
</code></pre>
<p>把命名空间打印出来大致如下:</p>
<p><img src="https://med1844.github.io/zh/build-a-compiler-3/NS.png" alt="NS" /></p>
<p>上半部分和下半部分的节点是一一对应的，很容易就能看出来每个节点对应的命名空间。</p>
<p>有了命名空间之后，就应该考虑一下查找的问题了。</p>
<p>很显然，从当前节点一路向上溯根，在每个经过的节点上看一下当前正在查询的id是否在当前节点对应的命名空间内被声明过即可。</p>
<p>但是由于没有提供father的引用，因此要使用额外的数据。在这里，我用了一个字典<code>nsInheritance</code>，记录子命名空间到父命名空间的映射关系:</p>
<p><img src="https://med1844.github.io/zh/build-a-compiler-3/NS_Inheritance.png" alt="NS_Inheritance" /></p>
<p>由于是树状结构，因此每个子命名空间必定只能对应一个父命名空间，所以简单映射一下即可。</p>
<p>之后的查找，实现起来也很简单:</p>
<pre data-lang="python" class="language-python "><code class="language-python" data-lang="python">@aar.action(&quot;id_var&quot;)
def _id_var(id_):
    varName = &quot;__v_%d_%d_%s&quot; % (id_.ns[0], id_.ns[1], id_.getContent())
    if &quot;dec&quot; in id_:
        if id_.type[0].islower():
            id_.var = Variable(varName, id_.type, id_.ns)
    else:
        ns = id_.ns
        while True:
            tempVarName = &quot;__v_%d_%d_%s&quot; % (ns[0], ns[1], id_.getContent())
            if tempVarName in declaredVars[ns]:
                id_.var = declaredVars[ns][tempVarName]
                break
            if ns not in nsInheritance:
                print(&quot;[ERROR] Undefined variable: %s has not been declared yet.&quot; % varName)
                exit()
            ns = nsInheritance[ns]
</code></pre>
<p>这样的话，就算重名了也没关系了。</p>
<p>接下来，要在函数的statementList被解析并生成ILOC前，需要给它的代码块加上从栈中读取参数的代码:</p>
<pre data-lang="python" class="language-python "><code class="language-python" data-lang="python">@aar.action(&quot;funcDec&quot;, index=3)
def _funcDec_3(func, type_, func_id, defpl, sl):
    offset = 4  # return address need 4 bytes
    for var in defpl.list:
        sl.cb.addILOC(&quot;mov&quot;, &quot;ebx&quot;, &quot;[esp + %d]&quot; % offset)
        sl.cb.addILOC(&quot;mov&quot;, var.getOP(), &quot;ebx&quot;)
        offset += var.size
</code></pre>
<p>最后，补全生成函数调用的代码:</p>
<pre data-lang="python" class="language-python "><code class="language-python" data-lang="python">@aar.action(&quot;functionCall&quot;)
def _funcCall(funcCall, funcName, paramList):
    if str(funcName) in builtinFunctions:
        builtinFunctions[str(funcName)](paramList)
    else:
        func = declaredFunctions[str(funcName)]
        if len(paramList.getChilds()) != len(func.parameters):
            print(&quot;[ERROR] Function call: Parameter number don&#x27;t match.&quot;)
            exit()
        funcCall.cb.addILOC(&quot;push&quot;, &quot;eax&quot;)
        funcCall.cb.addILOC(&quot;push&quot;, &quot;ebx&quot;)
        totSize = 0
        for i in range(len(func.parameters) - 1, -1, -1):
            if not match(func.parameters[i], paramList.list[i]):
                print(&quot;[ERROR] Function call: Parameter %d don&#x27;t match.&quot; % i)
                exit()
            var = paramList.list[i]
            funcCall.cb.addILOC(&quot;push&quot;, var.getOP())
            totSize += var.size
        funcCall.cb.addILOC(&quot;call&quot;, func.sl.name)
        funcCall.cb.addILOC(&quot;add&quot;, &quot;esp&quot;, str(totSize))
        funcCall.var = Variable(getTempVarName(), func.returnType, funcCall.ns)
        funcCall.cb.addILOC(&quot;mov&quot;, funcCall.var.getOP(), &quot;eax&quot;)
        funcCall.cb.addILOC(&quot;pop&quot;, &quot;ebx&quot;)
        funcCall.cb.addILOC(&quot;pop&quot;, &quot;eax&quot;)
</code></pre>
<p>这样就可以实现函数调用了。</p>
<h2 id="cheng-guo">成果</h2>
<p>根据这些已经实现的代码，写一点可以跑的简短程序，作为最后的综合测试:</p>
<p><img src="https://med1844.github.io/zh/build-a-compiler-3/synthesizedTest.png" alt="synthesizedTest" /></p>
<p>它生成的代码如下:</p>
<p><img src="https://med1844.github.io/zh/build-a-compiler-3/FinalResult.png" alt="FinalResult" /></p>
<p>完结撒花。</p>
<h2 id="fan-si">反思</h2>
<p>学到了很多，也思考了很多。</p>
<p>尽管了解了寄存器，了解了运行原理，了解了汇编的写法。但我总觉得，还远远不够啊。</p>
<p>连数组都没有实现; 只是因为觉得要实现引用的话还得先实现类定义就嫌麻烦; 不知道汇编要怎么分配堆内存于是就想着跳过。好像不论做什么项目，回过头一看，理想总是丰满，现实何止骨感。</p>
<p>除了因为各种原因而没有实现的内容之外，在写这个编译器的时候，我总是在不停地想。</p>
<p>究竟怎样才能够写出灵活的架构呢?</p>
<p>虽然按照词法分析-&gt;句法分析-&gt;文法分析-&gt;IR-&gt;Code这样走下来，确实前面的部分不会太多干涉到后面的部分。比方说，就算要把CFG换成全新的文法，也只需要改一下直接相关的ParseTree的动作，后面已经写好的IR根本不用动。</p>
<p>但是，每个部分的内部，总是会显得不那么灵活。引入代码块的时候，我把前面几乎所有的action都重写了一遍，因为要加上<code>.cb</code>。引入命名空间时，居然会因为查找算法的bug而导致不能够正常运转，之前已经能编译的程序居然也会开始报错。又或者，为了提高性能，最后居然要重写整个模块。</p>
<p>是因为写到后面就开始心急了吗? 是因为后面，已经开始进入教科书不会详细说明的部分了吗?</p>
<p>如果我现在突然希望加入优化器呢? 那优化器的结构又该是怎样呢? 现在的结构能够以很小的代价支持优化器的加入吗? 现在的IR真的算得上是合格的IR吗? 能跑就是全部吗? 为什么不先去看看工业级的编译器的架构呢? <strong>难道自己就只满足于小打小闹般的<em>写着玩</em>吗? 以这么低的水准要求自己合适吗?</strong></p>
<p>这样的问题，我只能在心里默默地问，却不知道怎么回答。</p>
<p>不敢面对。</p>
<p>好像每次只要自己开始写一些巨大的东西，就会犯各种错误。总是会写着写着发现当初没有考虑到这样那样的需求，而功能的分离又总是做的很差，于是每写一段时间就要花更多的时间拿来优化项目的结构。这样循环往复迭代几次，也就到了我能够承担的项目的极限大小了吧。如果说老师的能力是随手处理几十万行的C++程序的话，那么才几千行python的我，修行之路真的还很漫长啊。</p>
<p>好像每次只要在开始写之前没有非常详尽的对类的安排以及实现方案的话，就非常容易写着写着开始<em>面向实现编程</em>，再次回到ACM的路上，只要能写出来能跑就行，不考虑任何未来的需求。</p>
<p>我想，接下来到开学前那段时间，可能需要好好花时间修行设计模式才行了。</p>
<p>也许再过一段时间，回头一看。</p>
<p>又会像去年12月那样，像批评minecrash那样批评这个编译器了吧。</p>
<p>未尝不是一件好事呢。</p>
<h2 id="references">References</h2>
<ul>
<li>http://leto.net/writing/nasm.php</li>
<li>https://stackoverflow.com/questions/37407363/create-an-exe-file-in-assembly-with-nasm-on-32-bit-windows</li>
<li>https://kakaroto.homelinux.net/2017/11/introduction-to-reverse-engineering-and-assembly/</li>
<li>https://blog.csdn.net/gyrfalcon_sky/article/details/21713481</li>
<li>https://pdos.csail.mit.edu/6.828/2008/readings/i386/LAHF.htm</li>
<li>https://cs.lmu.edu/~ray/notes/nasmtutorial/</li>
<li>https://nasm.us/docs.php</li>
</ul>


<script>
  // Script to show/hide header based on scroll direction.
  const header = document.getElementById('page-header');
  if (header) {
    // Store the last scroll position.
    let lastScrollY = window.scrollY;

    window.addEventListener('scroll', () => {
      const currentScrollY = window.scrollY;

      if (currentScrollY > lastScrollY && currentScrollY > 50) {
        // If scrolling down and past the top, hide the header.
        header.classList.add('header-hide');
      } else {
        // If scrolling up or at the very top, show the header.
        header.classList.remove('header-hide');
      }

      // Update the last scroll position.
      lastScrollY = currentScrollY;
    });
  }
</script>

    </div>
  </section>
</body>

</html>
