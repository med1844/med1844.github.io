<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>FF14职业性格调查小问卷</title>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <link rel="stylesheet" href="styles.css">
</head>

<body>
    <div class="content-wrapper">
        <div class="question-container">
            <h1>FF14职业性格调查小问卷</h1>
            <p>
                <a
                    href="https://www.wjx.cn/wjx/activitystat/verifyreportpassword.aspx?viewtype=1&activity=170647260&type=1">原问卷</a>
                <br>
                感谢<a href="https://space.bilibili.com/700818858">阿莉娅Aliya_</a>提供的初始答卷集合表格！
            </p>
            <div id="questionContainer"></div>
            <div id="submitContainer"></div>
        </div>
        <hr>
        <div id="myDiv" class="plot-container"></div>
    </div>

    <script>
        async function fetchQuestions() {
            try {
                const response = await fetch('questions.json');
                const questions = await response.json();

                generateQuestions(questions);
            } catch (error) {
                console.error('Failed to load questions:', error);
            }
        }

        function generateQuestions(questions) {
            const container = document.getElementById('questionContainer');
            questions.forEach((question, q_index) => {
                const section = document.createElement('section');
                const p = document.createElement('p');
                p.textContent = question.statement;
                section.appendChild(p);

                question.choices.forEach((choice, i) => {
                    const label = document.createElement('label');
                    const radio = document.createElement('input');
                    radio.type = 'radio';
                    radio.name = `question${q_index}`;
                    radio.value = i;
                    radio.onchange = () => updateSelection(i, q_index);
                    label.appendChild(radio);
                    label.appendChild(document.createTextNode(choice));
                    section.appendChild(label);
                    section.appendChild(document.createElement('br'));
                });

                container.appendChild(section);
            });
        }

        fetchQuestions();
    </script>

    <script type="module">
        import init, { calc_posterior } from "./pkg/client.js";
        await init();
        async function loadF64Array(name) {
            let response = await fetch(name);
            let buffer = await response.arrayBuffer();
            return new Float64Array(buffer);
        }
        const likelihood = await loadF64Array('likelihood.bin');
        const prior = await loadF64Array('prior.bin');

        const jobs_resp = await fetch('jobs.json');
        const jobs = await jobs_resp.json();

        // build the question of main job, so that we can store it
        const container = document.getElementById('submitContainer');
        const section = document.createElement('section');
        const p = document.createElement('p');
        p.textContent = "【可选，将用于提升预测精度】您的主职是";
        section.appendChild(p);

        jobs.forEach((job, i) => {
            const label = document.createElement('label');
            const radio = document.createElement('input');
            radio.type = 'radio';
            radio.name = `job`;
            radio.value = i;
            label.appendChild(radio);
            label.appendChild(document.createTextNode(job));
            section.appendChild(label);
            section.appendChild(document.createElement('br'));
        });

        function getSelectedJob() {
            const selectedRadio = document.querySelector('section input[name="job"]:checked');
            return selectedRadio ? selectedRadio.value : null;
        }

        // we need map instance available before we could build submit button
        var map = new Map();
        window.updateSelection = function (value, index) {
            map.set(index, value);
            let indices = Uint8Array.from(map.keys());
            let choices = Uint8Array.from(map.values());
            genPlotlyData(choices, indices);
        }

        const submitButton = document.createElement("button");
        submitButton.type = 'button';
        submitButton.textContent = "提交";
        async function submitToCloudflare(job_id, answers) {
            let body = JSON.stringify({
                job_id: job_id,
                answers: answers
            });
            console.log(body);
            let response = await fetch("https://ffxiv-pred-handler.medioqrity.workers.dev/", {
                method: "POST",
                headers: {
                    "Content-Type": "text/plain"
                },
                body: body
            });
            try {
                let data = await response.json();
                console.log("Response data:", data);
            } catch (err) {
                console.error("Error parsing JSON response:", error);
            }
        }
        submitButton.onclick = () => {
            let job = getSelectedJob();
            if (job !== null) {
                if (map.size === 22) {
                    let sortedAnswers = Array.from(map.entries())
                        .sort((a, b) => a[0] - b[0])
                        .map(tuple => tuple[1]);
                    submitToCloudflare(job, sortedAnswers);
                } else {
                    alert("有没回答的题，请再检查一遍")
                }
            }
        };
        section.appendChild(submitButton);
        container.append(section);

        // Global reference to the figure
        let plotInstance;

        function genPlotlyData(choices, indices) {
            var trace1 = {
                x: jobs,
                y: prior,
                name: 'Prior Distribution',
                type: 'bar',
                marker: {
                    color: 'rgba(192, 192, 192, 1.0)'
                }
            };
            let posteriors = calc_posterior(
                prior,
                likelihood,
                choices,
                indices,
            );

            let diff = prior.map((pri, index) => posteriors[index] - pri);
            let colors = Array.from(diff).map(d => d > 0 ? 'rgba(0, 221, 166, 0.7)' : 'rgba(255, 255, 255, 0.5)');

            var trace2 = {
                x: jobs,
                y: diff,
                name: 'Posterior Distribution',
                type: 'bar',
                marker: {
                    color: colors
                },
                base: prior,
            };

            var data = [trace1, trace2];

            var maxPosteriorValue = Math.max(...posteriors);
            var maxYValue = Math.max(maxPosteriorValue, ...prior) * 1.1; // 10% padding

            var layout = {
                title: 'Prior vs Posterior Distributions',
                barmode: 'overlay', // put bars on top of each other
                showlegend: false,
                yaxis: {
                    range: [0, maxYValue],
                    fixedrange: true
                },
                xaxis: {
                    fixedrange: true
                },
                margin: {
                    l: 50,
                    r: 50,
                    b: 50,
                    t: 50,
                    pad: 4
                }
            };

            let duration = 150;

            if (plotInstance) {
                const currentYAxisRange = plotInstance.layout.yaxis.range;
                if (currentYAxisRange[1] !== maxYValue) {
                    // if maxYValue changed, animate it first before animate bar
                    Plotly.animate('myDiv', {
                        layout: {
                            yaxis: {
                                range: [0, maxYValue]
                            }
                        }
                    }, {
                        transition: {
                            duration: duration,
                            easing: 'cubic-in-out'
                        },
                        frame: {
                            duration: duration
                        }
                    }).then(() => {
                        Plotly.animate('myDiv', {
                            data: data,
                            layout: layout
                        }, {
                            transition: {
                                duration: duration,
                                easing: 'cubic-in-out'
                            },
                            frame: {
                                duration: duration
                            }
                        });
                    });
                } else {
                    Plotly.animate('myDiv', {
                        data: data,
                        layout: layout
                    }, {
                        transition: {
                            duration: duration,
                            easing: 'cubic-in-out'
                        },
                        frame: {
                            duration: duration
                        }
                    });
                }
            } else {
                Plotly.newPlot('myDiv', data, layout).then(plot => {
                    plotInstance = plot;
                });
            }
        }

        window.onresize = function () {
            if (plotInstance) {
                var update = {
                    autosize: true
                };
                Plotly.relayout('myDiv', update);
            }
        };

        genPlotlyData(new Uint8Array(), new Uint8Array());
    </script>


</body>


</html>