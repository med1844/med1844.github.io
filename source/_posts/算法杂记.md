---
title: 算法杂记
date: 2020-03-28 02:29:37
tag: [c++, python]
category: 算法
mathjax: true
hidden: true
---

记录一些生活中/网上冲浪时/游戏里遇到的算法问题。有些有幸能用我浅薄的知识解出，有些则悬而未决。

## 星露谷与酒桶

星露谷。最大化利用率。

## 抽象话与NP-完全问题

最大独立集。

## 遮著相扑机与AC自动机

怎么高效地复原替换后的数据?

## 十七张牌与爆搜

这题是我内推某大厂笔试时的第一题，当然原标题不长这样就是了。似乎没有说不能发布，因此也就腆着脸贡献一下自己的写法。

### 题意

给你一叠扑克牌，你可以在每一步:

- 打出单牌，比方说$6$。
- 打出对子，比方说$99$。
- 打出顺子，必须是数字连续递增的5张牌，比方说$23456$。
- 打出连对，必须是数字连续递增的三个对子，比方说$334455$。

希望你计算出把这些牌打完的最少步数。

### 输入

一行，$10$个数字，每个数字$c_i \in [0, 4]$，代表数字是$i$的牌的个数。

### 输出

一行，一个数字，代表最少步数。

### 样例

输入:

```text in
1 1 2 2 2 2 2 1 1 1
```

输出:

```text out
3
```

### 解

这种求最少步数的基本都是爆搜或者dp。这题要是用dp做，可以考虑用一个$2^{30}$的数字表示状态（每个数字5个状态需要3个比特，10个数字30比特），向前转移，复杂度$\mathcal{O}(5 \cdot 2^{30})$，肯定是要爆的。只查询一次的话没必要这么大费周章，所以还是爆搜吧。

注意到当不能再打出连对和顺子的时候，就只能出单牌或者对子了。显然，我们可以贪心地打出对子，然后处理剩下的单牌。这样就剪掉了相当多的搜索。

所以，采用dfs，用一个int表示状态，减少内存占用（其实并没有），只搜连对和顺子，剩下的牌全部贪心打掉就可以了。

为了加速，同时也为了让代码看起来{% ruby 优雅|装逼 %}一点，把状态压了位，然后用146，4681之类的magic number对压缩的状态进行快速加减（其实也没啥magic的，看看它们的二进制就知道怎么回事啦）。

代码如下:

```c++ a_3.cpp
#include <cstdio>
using namespace std;

int ans = 0x7fffffff;
bool flag = true, isSingle = true;

void dfs(int depth, int stat) {
  if (stat == 0) {
    if (ans > depth) ans = depth;
    return;
  }

  isSingle = true;

  // liandui
  for (int i = 0; i <= 7; ++i) {
    flag = true;
    for (int j = 0; j < 3 && flag; ++j)
      flag &= (((stat >> ((i + j) * 3)) & 7) >= 2);
    if (flag) dfs(depth + 1, stat - (146 << (i * 3)));
    isSingle &= !flag;
  }

  // shunzi
  for (int i = 0; i <= 5; ++i) {
    flag = true;
    for (int j = 0; j < 5 && flag; ++j)
      flag &= (((stat >> ((i + j) * 3)) & 7) != 0);
    if (flag) dfs(depth + 1, stat - (4681 << (i * 3)));
    isSingle &= !flag;
  }

  // single & duizi
  int cnt = depth, val;
  for (int i = 0; i < 10; ++i) {
    val = (stat >> (i * 3)) & 7;
    cnt += (val >> 1) + (val & 1);
  }
  if (ans > cnt) ans = cnt;
}

int main() {
  int temp;
  while (~scanf("%d", &temp)) {
    ans = 0x7fffffff;
    int init_stat = temp;
    for (int i = 0; i < 9; ++i) {
      scanf("%d", &temp);
      (init_stat <<= 3) |= temp;
    }
    dfs(0, init_stat);
    printf("%d\n", ans);
  }
}
```

恩，要是那17张牌是用这段代码来打的话，卢老爷大概也就不用骗吃骗喝了吧。

## 单调递增与LIS

这是笔试的第二题。写完切回去一看发现笔试刚结束，感觉自己亏了一个亿。好在最后还是补交上了。

### 题意

你有$n$个单调递增的字符串（$n < 10^6$），这里单调递增即是指每个字符的字母序都比前一个字符的字母序要大。希望你从中选取一些字符串，使得这些字符串可以以某种方式拼接成一段同样单调递增但更长的新字符串。你的目标是求出这个新字符串$s$的最大长度。

### 输入

一行整数$n$，代表字符串的个数。接下来$n$行，每行一个字符串$s_i$，保证$|s_i| \le 100$且$\sum_i|s_i| \le 10^7$。

### 输出

一个整数，代表最大长度。

### 样例

输入:

```text in
5
aaa
bbb
cde
cdefg
zzz
```

输出:

```text out
14
```

### 解

稍微刷过dp的人应该都知道这就是LIS的变体。

假定$\mathrm{dp}[i]$代表到字母$i$为止，能组成的最长的字符串的长度。不过仅仅这样还不够。由于每个字符串只能被使用一次，所以我需要记录已经被选用的字符串有哪些。一个相当{% ruby 简单有效 | 装逼 %}的办法就是压位。这样，被选用的字符串就可以用一个int表示了。

这样，就可以利用$\mathrm{dp}[i]_0$表示最长长度，$\mathrm{dp}[i]_1$表示已经用过的字符串有哪些。它们的状态转移关系是:

{% raw %}
$$
\mathrm{dp}[i]_0 = \max_{j < i, \big\lfloor\frac{\mathrm{dp}[j]_1}{2^z}\big\rfloor\bmod 2 \equiv0}(\mathrm{dp}[i]_0, \mathrm{dp}[j]_1 + |s_z|)
$$
{% endraw %}

其中$z \in [0, n)$。这样的话，复杂度显然就是$\mathcal{O}(26^2 \cdot n)$

一个可供加速的地方就是，对于通篇只有同一种字符的字符串，可以直接把它们合并成一个。于是可以先写出这部分优化:

```python
def f(char):
    return ord(char) - ord('a')


mono = {i: 0 for i in range(26)}


n = int(input())
l = []
for _ in range(n):
    s = input()
    if f(s[0]) == f(s[-1]):
        mono[f(s[0])] += len(s)
    else:
        l.append(s)
for k, v in mono.items():
    if v:
        l.append(chr(k + ord('a')) * v)
```

另外一个可以加速的地方是，我们可以用字符串末尾的字符对字符串进行分类。这样可以减少对无关字符串的访问:

```python
ending = {}

for i, s in enumerate(l):
    ending.setdefault(f(s[-1]), []).append((f(s[0]), f(s[-1]), len(s), i))
```

接下来就是简单地声明`dp`数组，并赋以初值:

```python
dp = [[0, 0] for _ in range(26)]
for index, s in enumerate(l):
    if len(s) > dp[f(s[-1])][0]:
        dp[f(s[-1])][0] = len(s)
        dp[f(s[-1])][1] = 1 << index
```

然后实现上面那个吓人的转移方程，并打印结果:

```python
for i in range(26):
    try:
        for st, en, le, ind in ending[i]:
            for j in range(st):
                if not (dp[j][1] >> ind) & 1:
                    if dp[j][0] + le > dp[i][0]:
                        dp[i][0] = dp[j][0] + le
                        dp[i][1] = dp[j][1] | (1 << ind)
    except KeyError:
        pass
print(max(v[0] for v in dp))
```

这两题都不是很难，大概是codeforces上div2的C题的水平，也算是侧面验证了Google员工所说的工作中1700分就够用的说法吧。尽管如此，因为我已经太久没有刷题，所以在笔试的时候颇有翻车的感觉。果然还是不能轻敌啊。