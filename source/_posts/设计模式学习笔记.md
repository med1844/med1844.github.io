---
title: 设计模式学习-笔记
date: 2020-12-31 20:33:25
tags: [设计模式, java]
categoty: 造轮子
hidden: true
---

采用Head First设计模式中文版。

参考费曼技巧，以及该书的序章所写的内容，我想笔记也是可以成为具有学习价值的材料的。前提是需要遵守一些规矩，如：

- 使用正常人聊天的语气来叙说内容，而不是干巴巴的正式文档的口气
- 多使用图片来解释内容
- 影响读者的情绪（生草等）

与教科书不同的是：

- 对于书中提出的难点，应当写下自己的思考（不然还叫笔记吗），而不是*让学习的人想得更深*

毕竟笔记是为自己而写，因此应当隐藏。

# CHAPTER 1 - 设计模式入门

## 模拟鸭子：策略模式

为了给模拟鸭子程序中的鸭子加入飞行功能，在所有鸭子的超类中加入一个fly方法即可。

但是这样就会产生橡皮鸭会飞的feature（mojang感）。一个可行的解决方案是用空代码override掉超类的fly方法。

这样会导致：

- 代码在多个子类中重复
    - 橡皮鸭和烤鸭都不会叫，都得写个一模一样的空函数override掉超类方法
- 运行时的行为不容易改变
    - 比方说橡皮鸭被装备上了KS-25x4“猛犸”液体燃料引擎，不就能飞了？
    - 如果此时的飞行控制方法又与原先的正常鸭子的飞行控制方法不同，该怎么办？
- 我们很难让鸭子跳舞
    - 无生命的东西除非加入可控制骨架机器人，否则就算是天王老子来了它也不能跳舞
    - 难道每增加一个有生命的鸭子才能做的功能，都得重新往每个无生命鸭子的子类里复制一次空函数吗？
- 改变会牵一发而动全身，造成其他鸭子不想要的改变
    - 正如上面所说，加入跳舞的功能（仅供可活动的鸭子使用），或者加入喝机油补充能量的功能（仅供机器鸭使用），放在超类的抽象等级太高，所有鸭子都会受影响，放在子类则太麻烦，而且也不方便改

一种可行的解决方案是将fly()和quack()的feature分离成interface，每个需要fly和quack的鸭子子类都可以继承它们。但是缺点也非常明显：

- 如果哪一天我们认为飞行实在太容易导致穿模bug或者需要计算的碰撞太多，由于经费原因不得不砍掉这个功能（就像2077的爬墙功能），那么每个继承了fly的鸭子子类都要逐一修改实现的接口列表。
    - 虽然也可以通过将fly()改成空函数实现...但是留着一个完全没用的类，我想是应当避免的行为？
- 如果我们希望火箭鸭有一套完全不同的操控方式，就像钩爪鸭和浮空鸭那样？难道我们要修改成`implements RocketFly`这样吗？

### 软件开发定理与第零设计原则

定理：无论是什么项目，我们所做的事情无非是**改动**。

比方说：

- 写编译器的时候，发现先前的类划分完全是错误的：不仅在逻辑上行不通，由此导致的算法改变也极大地降低了效率。结果，不仅得把所有类重新写一遍，还得把所有的算法都重写。
- 写shader loader的时候，发现之前的渲染过程满是错误，想要切换到deferred shading，结果得把渲染器的核心部分全部重写一遍
- 写时间系统的时候，直接把天色、雾的浓度、太阳位置与角度、平行光的角度全部放在一个函数里控制，但其实应该分开的，所以得为此将这部分内容分离到各个对应类中，但是要怎么分离呢？

因此，我们可以得出第零设计原则：

**将应用中可能需要变化的地方全部独立出来，不要和不需要变化的代码混在一起。**

这样，我们就能有效地应对**变化**，并且有信心面对更多地同类型变化。

这里，鸭子的行为会变化，因此将**鸭子的行为**抽取出来，作为额外的类使用（非常反直觉，但这确实是重点。*另外我认为这里选择如此反直觉的类来提取的逻辑非常值得反复体会*）。

这样，不同的行为可以使用不同的行为类来实现，比方说飞行行为类及其子类（火箭操控？扇翅膀？还是QWOP风格？或者卫星姿态机动？），呱呱叫行为（机械嗓音？丧尸嗓音？还是像龙那样喷火？）

### 第一设计原则

我们希望鸭子的行为可以在运行时改变（这样就可以通过吃道具来改变行为了！比方说参考马里奥吃火焰花，我们也可以通过吃冰冻花来打造最强冰冻鸭子之类的），这样就引出了一个非常重要的的原则：

**针对接口编程，而不是针对实现编程。**

我们可以通过`IFlyBehavior`和`IQuackBehavior`来作为接口，再赋以不同子类的实例，这样鸭子类就成功地实现了*无需了解行为类的细节*这一点。

我们甚至可以再抽象出`IBehavior`类，来更抽象地表达所有可能的动作（如跳舞，奔跑，驾车，开枪，写代码等）。当然，仅当动作本身也成为了可变对象时，我们才应该这么做（此时符合第零设计原则）。

这利用了接口本身的特性：接口不变，而实现可变。

与以前的做法不同的是，以前的fly方法都是在父类中彻底写死的。想要修改，则只能在子类中修改。而即便在子类中修改，它也是写死的。

### 鸭子暖暖

这部分是我自己的思考记录。

既然鸭子的行为本身可变，那么为什么鸭子的颜色不抽象成一个类呢？

事实上这是因为——不同子类的鸭子，已经有着不同的颜色和外观。由于不同类的鸭子与颜色直接对应，因此这里不需要再抽象鸭子的外观。

除非我们希望外观也能变化：比方说，将红头鸭子染成蓝色，或者加入隐身功能变身忍者鸭这种情况，或者是出现了外观相同却需要使用不同行为的子类（如普通鸭子和声带坏死被加装了发声义体的赛博朋克鸭子，外观一致但是需要不同的`IQuackBehavior`实现，甚至不同的`IAIBehavior`，就像2077的奥特那样）。由于产生了重复，或者希望运行时改变，或者有着额外的运算逻辑（如隐身），此时才需要将颜色抽象成一个类。

也许还有别的需要将其进行抽象的情况，但总的来说无外乎还是第零原则那样：提取变化。在现在的设计中，Duck本身各个类型的不同已经足够代表其颜色，因而没有额外的变化需要考虑。

### 代码实现

![](设计模式学习笔记\Ducks.png)

这样做，确实可以更换Fly的行为模式，加装了火箭。大大提高了灵活性，同时将行为逻辑的代码彻底从鸭子类中分离。

我应该使用`AbstractDuck duck = new ModelDuck()`的，但是毕竟已经是最终Application了，大概不这么面向接口也没啥大问题。

这里，`ModelDuck` **is a** `Duck`, `Duck` **has a** `IFlyBehavior` and **has a** `IQuackBehavior`, `FlyNoway` **implements** `IFlyBehavior`, so does `Quack` **implements** `IQuackBehavior`。加粗的黑字体现了它们之间的关系：抽象类的子类依旧 **is** 该类，接口的实现 **implements** 该接口，客户（即`Duck`）**has a** 算法簇（即`IBehavior`）。

这里的**has a**就是组合（composition）。

### 第二设计原则

**多用组合，少用继承。**

组合的意义在于可以使用setter方法，搭配接口，实现**运行时动态地改变行为**。

### 设计谜题_0

总之就是游戏里面角色与武器的设计。有多种角色，并且都能够使用武器进行战斗；每种武器有不同的战斗方式。给定类，请画出UML。

我的成果如下：

![Puzzle_0](设计模式学习笔记\Puzzle_0.png)

## 气象站：观察者模式

我们有一个`WeatherData`对象，它将从气象站获取湿度、温度和气压数据，并将数据发送给各显示装置。

每当气象站数据更新时，该类的`measurementsChanged()`方法就会被调用。此外，它还有三个getter方法：`getTemperature(), getHumidity(), getPressure()`。

我们需要在气象站数据更新时更新所有的布告板。目前我们有*当前状况*、*气象统计*和*天气预报*三个布告板。

首先我们来看错误的实现方式：

````java
public class WeatherData {
    public void measurementsChanged() {
        float temp = getTemperature();
        float humidity = getHumidity();
        float pressure = getPressure();
        
        currentConditionDisplay.update(temp, humidity, pressure);
        statisticsDisplay.update(temp, humidity, pressure);
        forecastDisplay.update(temp, humidity, pressure);
    }
}
````

我们注意到其中出现了一些重复，比方说`.update(temp, humidity, pressure)`。这样，各个布告板都被写死了，每当添加新的布告板，都需要手动添加并重新编译。

这还意味着我们不能动态地加入或删除布告板。当一个布告板因为个中原因离线时（比方说被赛博精神病砍坏了），weather data类还将不断地调用该布告板的`update`方法。

根据第零原则来看，这个程序没有将可变的部分和不会变的部分分离开。假定温度、湿度和气压等数据不会在将来添加或者修改，我们应该认为这部分是不变的。而需要改动的Display部分却写死了，并且没有分离开。

我不清楚`*Display`是不是单独的类。如果是的话，应该建立一个`IDisplay`的接口，并声明`public void update(float, float, float)`方法，再让子类进行实现。这样就可以符合第一设计原则。另外，通过使用`LinkedList<IDisplay>`，可以动态地加入或删除布告板。

这是实现动态的一种方式，重点是我们应该把这个`LinkedList`放进另一个类里。

