---
title: 一些关于DFS/BFS、DP、树与图的思考
date: 2021-07-13 01:13:01
tags: [c++, python]
category: 算法
mathjax: true
---

时光匆匆，大学就这么结束了。

为了还能在几十年后有一些念想，所以试图抢救了一些记忆。这篇文章就是其中之一。

---

还记得刚上数据结构这门课的时候----那时我已经熟练地掌握了深度优先搜索（**D**epth **F**irst **S**earch）与宽度优先搜索（**B**readth **F**irst **S**earch）----惊奇地发现书中介绍树的章节也介绍了树的深度优先遍历与宽度优先遍历。

那时我还想，不过只是DFS和BFS的特例罢了。

直到两年后的大四，在我思考二维平面迷宫作为四叉树的性质时才突然意识到，DFS与BFS才是被强行剥离出来的知识点。而将DP与DFS分开讲，甚至是在树型结构都没有让新生了解的情况下就接触这些，是十足的灾难。

遗憾的是，我见到过的几乎所有的教程，在介绍这方面内容时都只是人云亦云，将如此重要的内容随便拆散而全然不提背后的关联，让新生听得不明所以，实在不是负责任的态度。

虽然写了这些牢骚，但这篇文章依然不是为新生而写，只需看看各小节标题便知。

## 二维平面迷宫、四叉树、MST与平面图

回想二维平面迷宫的生成算法之一，即基于Kruskal、并查集与随机边权的平面图的算法。该算法通过对随机边权的平面图求最小生成树，最终生成了四叉树。丢弃的边即是呈现为障碍墙的部分。

当然，若是严格MST，则结果必定是树。否则，没有丢弃的边便一定会导致结果退化为图。

我好奇是否存在一种算法，该算法能够根据输入的树状结构反推出其是否能够被表示为一个二维迷宫，或者更正式地说，该树是否是某个二维平面图的MST。

当然以我的脑子自然是没什么机会想出这样的算法的。也许所有节点个数为平方数的四叉树都可以表示为迷宫？这就需要证明这两个集合相等，或存在一种映射方式（也就是程序），使得这两个集合之间能够一一对应；或者更简单，证伪。

无论如何，在思考这个问题时，我突然意识到刚入门DFS与BFS时那道经典例题：

> 给定一个$n \times m$的迷宫，入口处在$(0, 0)$，出口处在$(n - 1, m - 1)$，求通过迷宫的最短路径的长度。

根据前面的将迷宫看作四叉树的思想来看，将入口的$(0, 0)$对应的树上节点作为根节点，那么要求的就是$(n - 1, m - 1)$对应节点的深度，其本质上就是树上两点之间的唯一路径的长度。若迷宫并非四叉树，而是上面所说的退化的图的话，那么它就可能会有多条路径，最终就需要选择长度最短的路径。

对于有多条路径的图，只需简单记录访问过的点并在搜索时加以规避即可将该图转化为四叉树。这是因为这种规避本质上等于删去从当前节点出发到该已访问节点的边。删去多余的边后，平面图就可以转化为四叉树。

上述观察表明了二维平面迷宫的本质，也就是四叉树上的最短路。所谓深度/宽度优先搜索，本质上就是在四叉树上的深度/宽度优先遍历。为了加强理解，再次重复其核心原理：

0. 将平面图转化为以入口对应节点为根节点的四叉树。

    此处我们实现的方式是记录已访问的节点并移除指向已访问节点的边。然而其他任意一种能实现同样效果的方式也是可以接受的。

    对于本身就是四叉树的输入来说，则上述操作不会对输入有任何改变。

1. 在该四叉树上搜索代表出口对应的节点。

深搜与宽搜都能找到最短路。其差别在于：

- 深搜使用更少的内存，因为栈中存储的节点输不超过树的最大深度。代价是需要遍历所有节点才能确定最短路。
- 宽搜可以搜索更少节点，因为任何超过出口对应节点深度的节点都无需访问。代价是队列中存储的节点数最多时可能有树的宽度那么多。

迷宫为我们提供了一个有趣而直观的切入点。接下来我们将拓展节点的概念。

## 斐波那契数列、推箱子、状态图与自动机

树的节点本身究竟该拥有什么含义呢？

在前一小节的例子中，树的节点代表着实际迷宫的格子。在编译器的前端中，解析树的节点代表着上下文无关文法的终结符或非终结符。在composite设计模式中，每个基本类和每个复合类的实例都对应着树上的某个节点。

似乎树的节点上就该用来存储实际的数据，对吗？

不是的。树的节点还可以代表**状态**。

让我们用最经典的，每个DP教程都会谈到却根本说不明白为什么要DP的斐波那契数列作为例子。斐波那契数列的定义如下：
$$
\begin{cases}
f_{0, 1} = 1\\\\
f_{n} = f_{n - 1} + f_{n - 2}
\end{cases}
$$
将斐波那契数列的第$i$项作为状态理解（这会有些难理解，但是）。为了达到这一状态，必须有前置的两个状态$f_{i-1}$和$f_{i-2}$。因此，根据依赖关系画出边，就有从$f_i$指向$f_{i-1}$和$f_{i-2}$。容易发现，这三个节点形成了以$f_i$为根节点的树。递归地将$f_{i-1}$和$f_{i-2}$​​展开绘制子树，就能获得一棵计算顺序树。只需后续遍历即可完成计算。

![0](一些关于DFS-BFS、DP、树与图的思考\0.png)

容易发现，这棵计算顺序树的总节点数是指数级增加的（$f_n=2f_{n-2}+f_{n-3}$​）。

在这棵树中，状态之间的边反映了**状态之间如何转移**。这也是DP所谓状态转移方程的由来。

接下来考虑变量数目更多的状态。（待续）
